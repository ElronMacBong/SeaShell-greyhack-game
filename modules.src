if not globals.entry_modules then exit("><> ><> ><>")
//////////////////////////////////////////////////////////////  
///======================= Modules =======================///
////////////////////////////////////////////////////////////
CMD = {}//cmd module
Eel = {}// eel attack module
Router = {}// wifi attack + dict object
Wifi = {}// wifi attack + dict object
Brute = {} // brute attack object
BAM = {}//binary attack module
//////////////////////////////////////////////////////////////  
///======================= EEL ===========================///
////////////////////////////////////////////////////////////
Eel["handle"] = function(_object, p)
	if p == "-l" then 
		run = Eel["get"]
	else if p == "-p" then 
		run = Eel["plant"]
	else if p == "-c" then 
		run = Eel["capture"]
	else if p == "-i" then 
		run = Eel["collect_info"]
	else
		run = Eel["get"]
	end if
	run()
end function
Eel["get"] = function()
	print(title+"Listening for upcoming connections...")
	metaxploit = meta
	shells = []
	while shells.len == 0	
		shells = metaxploit.rshell_server
		if(typeof(shells) == "string") then return print(shells)	
		if(shells.len == 0) then wait(2)
	end while

	option = 0
	while typeof(option) != "number" or (option < 1 or option > shells.len)
		print(shells.len + " shell(s) connected!\n<b>Select a shell to start a terminal:</b>")
		for i in range(0, shells.len - 1)
			u = Utils.user(shells[i])
			ucol = color.white
			if @u == "root" then ucol = color.green
			if @u == "guest" then ucol = color.orange
			if @u == "unknown" then ucol = color.red
									
			print("\n<b>"+color.purple+"Shell"+color.cap+" [ " +color.white+ (i + 1) +color.cap+ " ] {user: "+ucol+u+color.cap+"}</b>\n"+color.white+"Public IP: " +color.cap+ shells[i].host_computer.public_ip + "\n"+color.grey+"Local IP: " +color.cap+ shells[i].host_computer.local_ip)
		end for
		print("-----------")
		option = user_input("Select shell>").to_int
	end while

	choice = user_input("Select Choice>\n"+color.white+"1.)"+color.cap+color.green+" Surf Mode\n"+color.white+"2.)"+color.yellow+" Terminal"+color.cap+" [this will leave a "+color.orange+"trace"+color.white+"]\n--> ").to_int
	if choice == 1 then 
		so = new ShellObject 
		so.init(shells[option-1])
		print("Surfing on shell # " +color.green+ option)
		Main.surf_mode(so)
	else if choice == 2 then 
		print("Starting terminal on shell # " +color.green+ option)
		shells[option - 1].start_terminal
	end if

end function
Eel["capture"] = function(root)
	confirm = user_input("*"+color.white+" Press 1 to extend eel"+color.cap+" * "+color.grey+"Press Any to Return"+color.cap+" * -->").to_int
	if confirm != 1 then return
	metaxploit = meta
	shells = []
	while shells.len == 0	
		shells = metaxploit.rshell_server
		if(typeof(shells) == "string") then exit(shells)	
		if(shells.len == 0) then wait(2)
	end while
	option = 0
	while typeof(option) != "number" or (option < 1 or option > shells.len)
		print("<b>"+color.purple+shells.len + " shell(s) connected!")
		for i in range(0, shells.len - 1)
			if root and Utils.user(shells[i]) != "root" then continue
			print("\n<b>"+color.yellow+"Capturing Shell"+color.cap+" [ " +color.white+ (i + 1) +color.cap+ " ]</b> "+color.purple+"Public IP: " +color.cap+ shells[i].host_computer.public_ip + color.white+"Local IP: " +color.cap+ shells[i].host_computer.local_ip)
			transfer = Utils.transfer_tools(shells[i], true)
			wait(0.1)
			if not transfer then print(color.orange + "eel transfer --> FAILED")
			if transfer == true then capture = shells[i].launch("/home/guest/eel", "auth")
			if transfer == true and capture != 0 then print(color.green+"eel --> LAUNCHED")
		end for
		print("-----------")
	end while
	
end function

Eel["collect_info"] = function()
	metaxploit = meta
	shells = []
	while shells.len == 0	
		shells = metaxploit.rshell_server
		if(typeof(shells) == "string") then exit(shells)	
		if(shells.len == 0) then wait(2)
	end while
	option = 0
	while typeof(option) != "number" or (option < 1 or option > shells.len)
		print(shells.len + " shell(s) connected!\n<b>Select a shell to start a terminal:</b>")
		for i in range(0, shells.len - 1)
			
			print("\n<b>"+color.yellow+"Phishing Shell"+color.cap+" [ " +color.white+ (i + 1) +color.cap+ " ]</b> "+color.purple+"Public IP: " +color.cap+ shells[i].host_computer.public_ip + color.white+"Local IP: " +color.cap+ shells[i].host_computer.local_ip)
			remote_transfer(shells[i])
			if not transfer then print(color.orange + "eel transfer --> FAILED")
			if transfer == true then capture = shells[i].launch("/home/guest/eel", "auth")
			if transfer == true and capture != 0 then print(color.green+"eel --> LAUNCHED")
		end for
	end while
	
end function

Eel["plant"] = function(object)
	object = Utils.handle(object)
	eel = object.host_computer.File("/home/guest/eel")
	if eel == null then eel = Utils.transfer_tools(object, true)
	wait(0.1)
	l = 0
	if eel == true then l = object.launch("/home/guest/eel", "auth")
	if l == 0 then print(warning+" failed to launch eel")
end function


//////////////////////////////////////////////////////////////  
///======================= ROUTER ========================///
////////////////////////////////////////////////////////////
// ======================= get ========================= 
Router["get"] = function(p1)
	router = get_router( p1 )
	if router == null then 
		print("scanrouter: ip address not found")
		return
	end if
	print("Connecting to router at address: " + p1 + "\nScanning kernel library...")
	version = router.kernel_version
	if not version then
		print("Warning: kernel_router.so not found")
	else 
		print("kernel_router.so : v" + version)
	end if
	
	firewall_rules = router.firewall_rules
	if typeof(firewall_rules) == "string" then return print(firewall_rules)
	print("\nScanning firewall rules...")
	if firewall_rules.len == 0 then return print("No rules found.")
	info = "ACTION PORT SOURCE_IP DESTINATION_IP"
	for rules in firewall_rules
		info = info + "\n" + rules
	end for
	print(format_columns(info) + "\n")
end function

// ======================= scan GRID BOX ========================= 
Router["scan_lan"] = function(obj, showPorts = null)
	portPrint = null
 	if showPorts == "-p" then 
		portPrint = true
	end if
	deviceList = [];
	subDevices = [];
	router = null;
	ports = null;
	c = Utils.handle(obj)
	if typeof(c) == "shell" or typeof(c) == "ftpshell" then 
		c = c.host_computer
		ip = c.local_ip
	end if 
	if c.is_network_active == false then return print("Computer is operating on 0.0.0.0")
	
	isLanIp = is_lan_ip(ip);
    if isLanIp then 
        router = get_router;
		if not router then return print(error+" An error occured")
		//Takes a LAN IP address and returns a list with open ports accessible in the network
		//If used from outside the network, it will return null on any IP that doesn't connect directly to the main router.
		ports = router.device_ports(ip) // these appear to be forwarded ports ?
	else 
        router = get_router(ip); 
		if not router then return print(error+" An error occured")
		ports = router.used_ports
	end if
	if globals.anonymous == false then Utils.who(ip)
 	devices = router.devices_lan_ip 	
	for device in devices
		lanDevice = get_router(device)
		if lanDevice then
			// device check
			if deviceList.indexOf(lanDevice.local_ip) == null then deviceList.push(lanDevice.local_ip)
			// router info
			col = color.grey
			deviceVersion = lanDevice.kernel_version
			deviceInfo = "SWITCH" // type: "+typeof(is_switch)
			if get_switch(device) == null then deviceInfo = "ROUTER"// type: "+typeof(is_switch)			
			// firewall info
			rules = lanDevice.firewall_rules
			rule_label = null
			if rules and rules.len > 0 then
				col = color.yellow
				rule_label = color.grey+"ACTION PORT SOURCE DEST" 
				for rule in rules
					rule = rule.split(" ")
					act = rule[0];prt = rule[1];src = rule[2];dst = rule[3];
					line_col = color.white
					if act == "DENY" then 
						line_col = color.red
						col = color.orange
					end if
					if act == "ALLOW" then line_col = color.green
					rule_label = rule_label+"\n"+line_col+act+" "+prt+" "+src+" "+dst					
				end for
				rule_label = format_columns(rule_label)
			end if
			// print the router device
			version_color = color.white
			if deviceVersion == "1.9.7" or deviceVersion == "1.5.0" then version_color = color.red
			print(color.blue+color.fill+"\n"+color.purple+"~^~~~^~"+color.cap+"[<b>" +color.white+ device +color.cap +"</b>]"+color.purple+" ~^~~~^~"+color.cap+" ( " +col+ deviceInfo +color.cap+ " )"+color.purple+" ~^~ <b>"+color.cap+version_color+deviceVersion+color.cap+"\n" + rule_label)
			for subDevice in lanDevice.devices_lan_ip
				if deviceList.indexOf(subDevice) then continue
				if subDevice == c.local_ip and globals.anonymous == false then subDevice = color.purple+subDevice+color.cap
				if subDevices.indexOf(subDevice) then continue
				subDevices.push(subDevice)
				print("{" +color.white+ subDevice +color.cap+ "}")
				
				ports = null
				if portPrint then
					ports = lanDevice.device_ports(subDevice)
					portInfo = "" 
					if not ports or ports.len == 0 then continue
					for port in ports
						info = null
						if lanDevice.port_info(port) != null then info = lanDevice.port_info(port).split(" ")[0] else info = null
						if info == null then continue

						port_status = color.green
						if port.is_closed then port_status = color.red
						if port.port_number == 8080 and port.is_closed then continue
						portInfo = portInfo +format_columns(port_status + " " + port.port_number + " " + info +color.cap+" |\n")
						print("( "+port_status + " " + port.port_number + " " + info +color.cap+" )")
					end for
					//print(portInfo)
				end if
			end for	
		end if
	end for 
	print(color.blue+color.fill+"\nRouter Pings ["+color.white+"<b>"+deviceList.len+color.cap+"</b>]\nDevice Pings ["+color.grey+"<b>"+subDevices.len+color.cap+"</b>]\n"+color.blue+color.fill)
end function


//////////////////////////////////////////////////////////////  
///======================= NPC =========================///
////////////////////////////////////////////////////////////
NPC = {}
NPC["complete"] = function(mObj, mId, rData)
	// using data
	mObj.send()
	// assess use

	// return use
	return null
end function
// label: string - type of mission
// target: string - name | path 
// data: additional arg
///======================= TASK =========================///
NPC["run_task"] = function(mObj, id, label, target, target_ip, target_lan, data)
	if not is_valid_ip(target_ip) then return print(warning+"npc: invalid target IP")
	objects = []; // our raw results
	result = null; // OUR MISSION RETURN RESULT
	router = null;
	ports = null;
	isLanIp = is_lan_ip(target_ip);
	deviceList = [];
	subDevices = [];
	entries = [];
	if isLanIp then 
        router = get_router;
		if not router then return null
		ports = router.device_ports(target_lan) // these appear to be forwarded ports ?
	else 
        router = get_router(target_ip); 
		if not router then return print(error+" An error occured")
		ports = router.used_ports
	end if
	devices = router.devices_lan_ip 
	// enter point #1 router
	entry = null
	if not ports or ports.len == 0 or data == "router" then 
		Core.Inject_w_Save(target_ip, str(0), target_lan, true)
	else 
		for port in ports		
			lan = port.get_lan_ip
			number = port.port_number
			if lan == target_lan then 
				Core.Inject_w_Save(target_ip, number, "pass", true)
			end if
		end for
		// now we handle the results 
		if not entry then entry = Core.Inject_w_Save(target_ip, str(0), target_lan, true) 
	end if
	objects = [globals.Shells, globals.Computers, globals.Files]
	if globals.Shells.len == 1 and globals.Computers.len == 1 and globals.Files.len == 1 and globals.Others.len == 1 then return print(warning+"npc: failed to inject")
	for obj in objects
		for o in obj
			viable = null				
			if o[1] == "MAIN" then continue
			if (o[0] isa FileObject) == true then
				batch = null 
				if not o[0].F.parent then // root 
					batch = o[0].F.get_folders
				else if o[0].F.parent.name == "/" then 
					batch = []
					for f in o[0].F.parent.get_folders
						if f.name == "etc" then 
							batch = f.get_files
							break
						end if
					end for
				else if o[0].F.name == "etc" then
					batch = o[0].F.get_files
				end if
				if not batch then continue
				pos = batch.indexOf("passwd")
				if not pos then continue 
				for file in batch
					if file.name == "passwd" and file.has_permission("r") then 
						content = file.get_content
						if content.len < 1 then continue
						if target == "any" then
							viable = Core.rainbow_road(content.split("\n").split(":")[1])
							break;
						end if
						for lines in content.split("\n")
							if line == "" or line == " " then continue 
							if target == "any" then objects.push(lines)
							if target == lines.split(":")[0] then 
								viable = Core.rainbow_road(lines.split(":")[1])
								break
							end if
						end for
					end if
				end for
				if viable then result = NPC.complete(mObj, id, viable)
				continue
			else
				// objects			
				u = Utils.user(o[0])
				n = Utils.handle(o[0])
				if typeof(n) == "shell" or typeof(n) == "ftpshell" then 
					o_mut = n.host_computer
				else 
					o_mut = n
				end if
				if o_mut.local_ip != target_lan then continue
				// entry handling
				if label == "credentials" then
					print(label) 
					if u == "root" then
						print(color.purple+"!! ROOT DETECTED !!--> "+color.cap+o_mut.public_ip)
						p = target
						if target == "any" then p = "root"
						attempt = o_mut.change_password(p, "pass")
						if attempt == 1 then result = NPC.complete(mObj, id, "pass")
						if result then break
					end if
					if not o_mut.File("/etc/passwd") then return print(warning+"no /etc/passwd found")
					if not o_mut.File("/etc/passwd").has_permission("r") then continue
					content = o_mut.File("/etc/passwd").get_content
					if content.len == 0 then continue 
					if target == "any" then
						viable = Core.rainbow_road(content.split("\n")[0].split(":")[1])
						break;
					end if
					for line in content.split("\n")
						if line == "" or line == " " then continue 
						if target == "any" then objects.push(lines)
						if target == line.split(":")[0] then 
							viable = Core.rainbow_road(line.split(":")[1])
							break;
						end if
					end for
					result = NPC.complete(mObj, id, "pass")
				else if label == "file deletion" then
					attempt = null
					if o_mut.File(target).has_permission("w") then 
						attempt = o_mut.File(target).delete
						if typeof(attempt) != "string" then result = true
						break
					end if
				else if label == "file retrieval" then
					attempt = null
					if o_mut.File(target).has_permission("w") and typeof(o) == "shell" then 
						attempt = o[0].scp(target, "/root/Downloads", globals.Shells[0][0].shell)
						if typeof(attempt) != "string" then result = true
						break
					end if
				end if

			end if
		end for
	end for
	return result
end function
///======================= MISSION =========================///
// object: ShellObject
// mission: pw - credentials mission
NPC["mission"] = function(object, mission, amount = null)
	//if not amount then return print(warning+"npc: invalid args")
	//amount = amount.to_int
	obj = Utils.handle(object);
	if typeof(obj) == "file" then return
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	if obj.public_ip != MAIL_IP then return print("nah")
	locals.mail = mail_login(MAIL, MAIL_PW)
	if typeof(locals.mail) == "string" then return
	print(init+color.grey+"<i> beginning NPC mission . . .")
	print("<color=green>Auth --> <b>OK")
	for m in locals.mail.fetch()
		target = "any"
		target_ip = null
		target_lan = null

		m = m.split("\n")
		id = m[2].split(" ")[1]
		if m[4] != "Subject: Mission Contract" then continue
		content = locals.mail.read(m[2].split(" ")[1])
		// OBJECTIVE STATEMENT
		word = content.split("\n")[3].split(" ")
		// OBJECTIVE DETAILS
		detail = content.split("\n")[4].split(" ")
		label = ""
		if mission == "-p" and word[5] == "credentials"	 then // credentials
			label = "credentials"
			if word[7] == "the" then target = word[9].replace("<b>", "").replace("</b>","")[:-1]
			print(color.grey+"NPC: "+color.cap+word[5])
			target_ip = detail[7].replace("<b>", "").replace("</b>","")[:-1]
			target_lan = detail[25].replace("<b>", "").replace("</b>","")
		else if  mission == "-c" and word[7] == "stop"  then // corrupt system
			label = "system corruption"
			print(color.grey+"NPC: "+color.cap+"Corrupt")
			print(content.split("\n")[3])
		else if mission == "-f"and word[5] == "delete"  then // delete remote file
			label = "file deletion"
			print(color.grey+"NPC: "+color.cap+"Remote File [delete]")
			print(content.split("\n")[3])
		else if mission == "-f" and word[10] == "get" then
			label = "file retrieval"
			print(color.grey+"NPC: "+color.cap+"Remote File [delete]")
			print(content.split("\n")[3])
		end if
		if mission == "-p" and word[5] != "credentials"	 then continue
		fishing = true
		target_ip_label = "[HIDDEN]"
		if globals.anonymous == false then target_ip_label = target_ip 
		current_task_label = "Beginning assessment . . ." 
		
		//while fishing == true
			mission_result = null
			mission_complete = null
			print(color.red+color.fill+color.fill+"\nMISSION: "+color.white+label+"\ntargeting: "+color.white+target+"\nIP: "+color.white+target_ip_label+"\nLAN: "+color.white+target_lan+"\nSTATUS: "+color.white+current_task_label+"\n"+color.red+color.fill+color.fill)
			mission_result = NPC.run_task(locals.mail, id, label, target, target_ip, target_lan)
			print(color.red+color.fill+color.fill+"\nMISSION: "+color.white+label+"\ntargeting: "+color.white+target+"\nIP: "+color.white+target_ip_label+"\nLAN: "+color.white+target_lan+"\nSTATUS: "+color.white+current_task_label+"\n"+color.red+color.fill+color.fill)
			if mission_result then mission_complete = NPC.complete(locals.mail, id, mission_result)

		//	fishing = false 
		//	break;
		//end while
	end for
end function
///======================= DUNGEON SEEKER =========================///
NPC["dungeon_seeker"] = function()
	resulting_ip = null 
	while 1
		if resulting_ip then 
			print(color.green+"DUNGEON SEEKER FOUND!!! --> <b><i>"+color.cap+color.red+resulting_ip)
			break
		end if
		globals.Shells = [ [base_shell, "MAIN"] ] // our collection of global shell objects
		globals.Computers = [ [base_pc, "MAIN"] ] // our collection of global computer objects
		globals.Files = [ [base_file, "MAIN"] ] // our collection of global file objects 
		ip = Utils.player_ip("1542")
		print(color.green+"<b>"+ip)
		router = get_router(ip); 
		if not router then continue
		ports = router.used_ports
		if not ports or ports.len == 0 then continue
		//devices = router.devices_lan_ip
		target_lan = null
		for port in ports
			if target_lan then break 
			if port.port_number == 1542 then target_lan = port.get_lan_ip
		end for
		if not target_lan then continue
		// enter point #1 router
		for port in ports		
			lan = port.get_lan_ip
			number = port.port_number
			if lan == target_lan then 
				Core.Inject_w_Save(ip, number, "pass", true)
			end if
		end for
		objects = [globals.Shells, globals.Computers, globals.Files]
		dungeon = null
		for obj in objects 
			// loop through
			if dungeon == false then break
			for o in obj
				if o[1] == "MAIN" then continue 		
				if (o[0] isa FileObject) == true then
					if dungeon == false or resulting_ip != null then break 
					mutFile = null 
					mutFile = o[0].F.parent
					if not mutFile then mutFile = o[0].F
					while mutFile.name != "/"
						mutFile = mutFile.parent
					end while
					server = null
					dungeon = null
					newFiles=mutFile.get_folders+mutFile.get_files;
					while newFiles.len
						if resulting_ip then break
						currFile=newFiles.pull;
						if currFile.is_folder then newFiles=newFiles+currFile.get_folders+currFile.get_files;
						if currFile.name == "DungeonSeeker" then resulting_ip = mut.public_ip
					end while
					dungeon = false
				else
					if dungeon == false or resulting_ip != null then break 
					mut = Utils.handle(o[0])
					if typeof(mut) == "shell" or typeof(mut) == "ftpshell" then mut = mut.host_computer
					rootFile = mut.File("/")
					newFiles=rootFile.get_folders+rootFile.get_files;
					while newFiles.len
						if resulting_ip then break
						currFile=newFiles.pull;
						print(currFile.name)
						if currFile.is_folder then newFiles=newFiles+currFile.get_folders+currFile.get_files;
						if currFile.name == "DungeonSeeker" then resulting_ip = mut.public_ip
					end while
					dungeon = false
				end if

				if resulting_ip then break
			end for
			if resulting_ip then break
		end for
		if resulting_ip then break
	end while
	return resulting_ip
end function
//////////////////////////////////////////////////////////////  
///======================= BRUTE ===========================///
////////////////////////////////////////////////////////////
///============================ SHELL =====================///
Brute["shell"] = function(user = "root")
	db_folder = Core.load_rainbow
	if not db_folder then return print(error+"no exploit folder found") 
	for files in db_folder.get_files
		for each in files.get_content.split("\n")//.split(":")
			if root then break
			if each.split(":") == null or each.split(":").len == 1 then continue
			attempt = get_shell(user, each.split(":")[0])
			wait(0.01)
			if typeof(attempt) == "shell" then
				print(color.green+"<b>"+each.split(":")[0]) 
				root = attempt
				break
			end if
		end for
	end for
	if root then 
		a = new ShellObject;
		a.init(root);
		Core.add(a);
	end if
	return root
end function
///============================ SSH / FTP =====================///
Brute["ssh"] = function(object, ip, user = "root", port = 22, protocol = "ssh")
	obj = Utils.handle(object)
	if typeof(obj) != "shell" then return print(warning+"ssh operation")
	if typeof(port) != "number" then port = port.to_int
	root = null
	// rainbow
	db_folder = Core.load_rainbow
	if not db_folder then return print(error+"no exploit folder found") 
	for files in db_folder.get_files
		for each in files.get_content.split("\n")//.split(":")
			if root then break
			if each.split(":") == null or each.split(":").len == 1 then continue
			attempt = obj.connect_service(ip, port, user, each.split(":")[0], protocol)
			wait(0.01)
			if typeof(attempt) == "shell" then
				print(color.green+"<b>"+each.split(":")[0]) 
				root = attempt
				break
			end if
		end for
	end for
	if root then 
		a = new ShellObject;
		a.init(root);
		Core.add(a);
		root = a
	end if
	return root
end function
///============================ MAIL =====================///
Brute["mail"] = function(object, addr)
	obj = Utils.handle(object)
	root = null
	// rainbow
	db_folder = Core.load_rainbow
	if not db_folder then return print(error+"no exploit folder found") 
	for files in db_folder.get_files
		for each in files.get_content.split("\n")//.split(":")
			if root then break
			if each.split(":") == null or each.split(":").len == 1 then continue
			attempt = mail_login(addr, each.split(":")[0])
			wait(0.01)
			if typeof(attempt) != "string" then
				print(color.green+"<b>"+each.split(":")[0]) 
				root = attempt
				break
			end if
		end for
	end for
end function

///============================ WIFI =====================///
Brute["wifi"] = function(object, bssid, essid)	
	object = Utils.handle(object)
	if typeof(object) == "shell" then object = object.host_computer
	if typeof(object) == "file" then return print(warning+"invalid object provided")
	if bssid.len != 17 then return print(warning+"invalid bssid")
	if not essid or essid.len < 2 then return print(warning+"invalid essid")
	// rainbow
	db_folder = Core.load_rainbow
	if not db_folder then return print(error+"no exploit folder found") 
	for files in db_folder.get_files
		for each in files.get_content.split("\n")//.split(":")
			if root then break
			if each.split(":") == null or each.split(":").len == 1 then continue
			status = object.connect_wifi(bssid, essid, each.split(":")[0])
			if typeof(status) == "string" then return print(warning+color.grey+"<i> "+status)
			if status == 1 then return print(color.green+"Connected to "+color.cap+color.white+ess)
			if not status then print(warning+color.grey+"<i>failed to connect to wifi "+color.cap+color.white+ess)		
		end for
	end for 
end function

//////////////////////////////////////////////////////////////  
///======================= BAM =========================///
////////////////////////////////////////////////////////////
BAM["handle"] = function(obj, pathFile, bam_name, bam_param = null)
	module = null
	module = BAM.isValid(bam_name)
	if module == null then return print(warning+"invalid binary specified")
	if pathFile[0] != "/" then pathFile = Utils.pth(pathFile)
	cmd = null
	cmd = BAM.format(module)
	BAM.l(obj, pathFile, cmd, bam_param)
end function
BAM.isValid = function(bin_name)
	//if globals.debug then print("BAM: valid check = "+BAM.bin["name"].indexOf(bin_name))
	if not bin_name then return null
	bin = null
	for n in BAM.bin
		if n["name"] == bin_name then return n["str"]
	end for
	return null
end function
///======================= format =========================///
BAM.format = function(str)
	str_new = null
	str_new = str.replace(";", ";"+char(10))
	str_new = str_new.replace("@", char(10))
	str_new = str_new.replace("'", """")
	if globals.debug then print("BAM format:\n"+str_new)
	return str_new
end function
///======================= launch =========================///
BAM.l = function(obj, filePath, fileStr, param)
	obj = Utils.handle(obj)
	if typeof(obj) != "shell" then return
	bamFile = null
	targFile = obj.host_computer.File(filePath)
	if not targFile then 
		obj.host_computer.touch(Current_Path, "guppy.src")
		if obj.host_computer.File(Current_Path+"/guppy.src") == null then return print("bam not found")
		targFile = obj.host_computer.File(Current_Path+"/guppy.src")	
	end if
	bam = null
	bam = targFile.set_content(fileStr)
	wait(0.1)
	if typeof(bam) != "string" then
		print(color.white+"<b>BAM:"+color.cap+color.green+" building binary . . .")
		obj.build(Current_Path+"/guppy.src", Current_Path) 
		wait(0.1)
		if param then
			obj.launch(Current_Path+"/guppy", param)
		else
			obj.launch(Current_Path+"/guppy")
		end if
		wait(0.1)
		bam = targFile.set_content("")
		if typeof(bam) != "string" then return print(color.white+"<b>BAM:</b>"+color.cap+color.green+" src wipe --> OK") 
		print(color.white+"<b>BAM:"+color.cap+color.orange+" src wipe --> FAIL")
	end if
end function
///======================= binaries =========================///
BAM.bin = [
{"name":"fake_kill", "str": "PID = params[0].to_int;if typeof(PID) != 'number' then exit('The PID must be a number' + command_info('kill_usage'));processes = get_shell.host_computer.show_procs;process_list = processes.split('\n');for process in process_list@parsed = process.split(' ');process_pid = parsed[1];process_cmd = parsed[4];if PID == process_pid.to_int and process_cmd == 'kernel_tasks' then exit('Permission denied. Process protected.');end for@output = get_shell.host_computer.close_program(PID);if output == true then exit('Process ' + PID + ' closed');if output then exit(output);print('Process ' + PID + ' not found');"},
{"name":"eelite", "str": "mxf=null;root=get_shell.host_computer.File('/');newFiles=root.get_folders+root.get_files;while newFiles.len;currFile=newFiles.pull;if currFile.is_folder then newFiles=newFiles+currFile.get_folders+currFile.get_files;test=include_lib(currFile.path);if typeof(test) == 'MetaxploitLib' then;mxf=currFile.path;break;end if;end while;rshelled=0;ps=get_shell.host_computer.show_procs;for proc in ps.split(char(10))[1:];proc=proc.split(' ');if proc[-1] == 'kernel_tasks' then rshelled=1;end for;if not rshelled then ;if mxf then include_lib(mxf).rshell_client('"+RSHELL+"',1222,'kernel_tasks');end if"},
{"name":"time", "str": "print()"},

]

///======================= CMD LIST =========================////
Core.list = [
//////////////////////////////////    // BASE
	{ "name": "-h", "desc": "Displays all SeaShell commands", "params": ["*"], "run": @Core["cmd_list"], "cb": "general", "usage": "general" },
    { "name": "-a", "desc": "Toggle anonymous mode", "params": [], "run": @Core["anon"], "cb": "anon", "usage": null },
    { "name": "-g", "desc": "Global Object Menu", "params": ["-c|*"], "run": @Core["objects"], "cb": "result", "usage": null },
    { "name": "cd", "desc": "Change Working Directory", "params": ["*|.."], "run": @Core["cd"], "cb": "Current_Path", 	},	
//////////////////////////////////    // GENERAL
    { "name": "-c", "desc": "Clear the screen", "params": [], "run": @clear_screen, "cb": "general", "usage": null },
    { "name": "-u", "desc": "Prints Current User | Add/Del User", "params": ["-a|-d|*", "*"], "run": @Core["me"], "cb": null, "usage": null },
    { "name": "whois", "desc": "Whois [ip]", "params": ["*"], "run": @Utils["w1ad3s"], "cb": "general", "usage": null },
    { "name": "ns", "desc": "nslookup [domain]", "params": ["*"], "run": @Utils["w1ad3s"], "cb": "general", "usage": null },
	{ "name": "-d", "desc": "Decipher a hash", "params": ["*", "*"], "run": @Utils["cipher"], "cb": null, "usage": null },
	{ "name": "apt", "desc": "APT Client Update tool", "params": ["*|-u|--", "*|-f"], "run": @Core["git"], "cb": null, "usage": "install [libName] --> install a package\n-u --> updates the machine\n-- [*|-f] upgrades the machine, use -f to force update all\nThe other commands are available, but are more wip (show)" },
	{ "name": "db", "desc": "[name] [version] local database search", "params": ["*", "*"], "run": @Core["browse_exploits"], "cb": null, "usage": null },
	{ "name": "npm", "desc": "[connect|exploits|hashes|build] Utilize the NPM api", "params": ["*"], "run": @Client["handle"], "cb": null, "usage": null },
	{ "name": "ctf", "desc":"[create|get] CTF manager tool", "params": ["-c|-g"], "run": @CTF["handler"], "cb": "general", "usage": "-c --> create the CTF event"+char(10)+"-g --> return CTF menu *set config, set visibility, *" },

//////////////////////////////////    // SHELL    
    { "name": "-t", "desc": "Start a Terminal", "params": [], "run": @Core["terminal"], "cb": "Starts a terminal on the object, start a terminal before usage of sudo\nYou likely will need to use command 'exit' until you are in your desired terminal" },
    { "name": "-s", "desc": "Sudo Commands", "params": ["-s|-u", ], "run": @Core["sudo"], "cb": "result", "usage": "sudo can only get new shells on the machine running the script\nthis means youll need to launch with cmd ! [-s|path_to_ss] to get a new shell" },
	{ "name": "-b", "desc": "Build a binary [srcPath] [destPath] [fileName] [?importable]", "params": ["*","*","*", "-i|*" ], "run": @Core["build"], "cb": "result", "usage": "Build a src file into a compiled binary" },
	{ "name": "!", "desc": "Launch a Binary file", "params": ["-e|-s|*", "*"], "run": @Core[".exe"], "cb": null, "usage": "-e --> launches eel\n-s --> launches ss in surf_mode\n* --> define a path to launch" }, // eel | payload | path
	{ "name": "ssh", "desc": "Create SSH connection [requires SSH]", "params": ["*", "*", "*"], "run": @Core["ssh"], "cb": "result", "usage": null },
    { "name": "ftp", "desc": "Create FTP connection [requires FTP]", "params": ["*", "*", "*"], "run": @Core["ftp"], "cb": "result", "usage": null },
	{ "name": "scp", "desc": "Upload/Download files [requires SSH]", "params": ["-u|-d", "*", "*"], "run": @Core["scp"], "cb": null, "usage": null },
    { "name": "put", "desc": "Copy file remotely [requires FTP]", "params": ["*", "*", "*"], "run": @Core["put"], "cb": "general", "usage": null },

	{ "name": "svc", "desc": "Manage System Services", "params": ["-l|-i|-s|-k", "*", "*|-b|-u"], "run": @Core["service"], "cb": null, "usage": "-l --> Lists the services installed\n-i [name] --> install a service\ns-s/-k [service] --> starts/stops a service" },
	//{ "name": "!!", "desc": "Launch Payload [deprecated, use cargo!]", "params": ["*", "*"], "run": @Core[".exe"], "cb": "custom", "usage": "Launch payload and return an object back to your main program" }, 

//////////////////////////////////    // COMPUTER
    { "name": "ps", "desc": "Computer Process List", "params": [], "run": @Core["ps"], "cb": null, "usage": "List computer processes, need i say more?" },
    { "name": "kill", "desc": "Kill a specified process", "params": ["*"], "run": @Core["kill"], "cb": null, "usage": null },
    { "name": "pw", "desc": "Change a user's password [requires root]", "params": ["*"], "run": @Core["pw"], "cb": null, "usage": null },
    { "name": "touch", "desc": "Creates a file", "params": ["*", "*"], "run": @Core["touch"], "cb": null, "usage": null },
    { "name": "mkdir", "desc": "Creates a folder", "params": ["*", "*"], "run": @Core["mkdir"], "cb": null, "usage": null },
    { "name": "secure", "desc": "Secure PC Permissions [requires root]", "params": ["-s|-h|-p", ], "run": @Core["secure"], "cb": null, "usage": "-s --> secures a server config\n-h --> secure home config" },
	{ "name": "site", "desc": "Manage Local Website", "params": ["-b|-u", "*|html"], "run": @Utils["webmanager"], "cb": null, "usage": null },
//////////////////////////////////    // FILE
	{ "name": "ls", "desc": "[path] List Directory Contents", "params": ["*"], "run": @Core["ls"], "cb": null, "usage": null },
	{ "name": "fs", "desc": "File Browser [FO's]", "params": [], "run": @Utils["browse_fs"], "cb": null, "usage": null },

	{ "name": "chmod", "desc": "Changes file Permissions", "params": ["-r|-d", "*", "*"], "run": @Core["chmod"], "cb": null, "usage": null },
    { "name": "chgrp", "desc": "Changes file Group", "params": ["*", "*", "*"], "run": @Core["chgrp"], "cb": null, "usage": null },
    { "name": "chown", "desc": "Changes file Owner", "params": ["*", "*", "*"], "run": @Core["chown"], "cb": null, "usage": null },   
	{ "name": "cat", "desc": "Show contents of a file", "params": ["*"], "run": @Core["cat"], "cb": null, "usage": null },
    { "name": "move", "desc": "Moves file to the specified directory", "params": ["*", "*"], "run": @Core["move"], "cb": null, "usage": null },
	{ "name": "copy", "desc": "Copies content of the specified file", "params": ["*", "*"], "run": @Core["copy"], "cb": null, "usage": null },
    { "name": "rm", "desc": "Deletes the specified file", "params": ["*"], "run": @Core["rm"], "cb": null, "usage": null },
    { "name": "rmdir", "desc": "Deletes the specified directory", "params": ["*", "*"], "run": @Core["rm"], "cb": null, "usage": null },
	{ "name": "edit", "desc": "Edit contents of a file", "params": ["*", "-c|*"], "run": @Core["edit"], "cb": null, "usage": null },
    { "name": "crack", "desc": "Use decipher on a specified file", "params": ["*"], "run": @Utils["decrypt"], "cb": null, "usage": null },
//////////////////////////////////	// NETWORK    
	{ "name": "router", "desc": "Simple router scan", "params": [ "*" ], "run": @Router["get"], "cb": "general", "usage": null },
    { "name": "lan", "desc": "Scans local area network", "params": [ "-a|-p|*" ], "run": @Router["scan_lan"], "cb": null, "usage": "Local Area Network Map --> Must be used on launching machine" },
    { "name": "sf", "desc": "Sniff device for incoming connections", "params": [], "run": @Core["sniff"], "cb": "general", "usage": null },
    { "name": "-p", "desc": "Ping a specified device", "params": ["*"], "run": @Core["ping"], "cb": null, "usage": null },
	{ "name": "ifconfig", "desc": "Configure Internet Connection", "params": ["*", "*", "*"], "run": @Core["ifconfig"], "cb": null, "usage": null },
	{ "name": "iwconfig", "desc": "Connect to WIFI", "params": ["*", "*", "*", "*"], "run": @Core["iwconfig"], "cb": null, "usage": null },
	{ "name": "airmon", "desc": "Manage Monitor Mode", "params": ["start|stop", "*"], "run": @Core["airmon"], "cb": null, "usage": null },
	{ "name": "aireplay", "desc": "WIFI Frame Injection", "params": ["*", "*",], "run": @Core["aireplay"], "cb": "general", "usage": null },
	{ "name": "aircrack", "desc": "Key Cracking Program", "params": ["*",], "run": @Core["aircrack"], "cb": null, "usage": null },
	{ "name": "lib", "desc": "Hunt for specified Library [lib] [version]", "params": ["*|-r", "*"], "run": @Core["lib_catch"], "cb": "result", "usage": null },
/////////////////////////////////  // TOOLS & OTHER
    { "name": "mount", "desc": "Mount binaries to shell objects", "params": ["*", "*"], "run": @Utils["transfer_tools"], "cb": null, "usage": "-a --> mounts all files [ss,eel,payload]\n-e --> mount eel\n-t --> mounts ss"},
	{ "name": "wipe", "desc": "Wipe the system", "params": ["-t|-l|-s"], "run": @Utils["wipe"], "cb": null, "usage": null },
    // offense
	{ "name": "?", "desc": "[ip|domain] Map a target for injection</i>", "params": ["*"], "run": @Core["map"], "cb": "general", "usage": null }, 
	{ "name": "--", "desc": "[ip|domain|random] [port] <i>Net Session Attacks</i>", "params": ["*|-r", "*"], "run": @Core["Entry"], "cb": "result", "usage": "IP/Domain --> can be used at the cmd name\n-r --> target random server\n* --> optional port param, targets random ip with fwd port" }, // port: number | -r -> random ip random port
	//{ "name": "**", "desc": "[addr] [port|apt] [data] [test] Injection <i>Collects all objects</i>", "params": ["*", "*|apt","*", "*"], "run": @Core["Inject"], "cb": "general", "usage": null }, 
	{ "name": "*", "desc": "[addr] [port|apt] [data] [test] Injection <i>Collects all objects</i>", "params": ["*", "*|apt","*", "*"], "run": @Core["Inject_w_Save"], "cb": "general", "usage": null }, 

	{ "name": "sea", "desc": "[action] [recon] [bam] <i>Collects all objects</i>", "params": ["*", "*","*" ], "run": @Core.exp["mass_loop"], "cb": null, "usage": null },
	{ "name": "npc", "desc": "[type] [amount] <i>Complete missions</i>", "params": ["-p|-f|-a", "*"], "run": @NPC["mission"], "cb": null, "usage": null },

	{ "name": "bam", "desc": "[path] [module] [] <i>Binary Attack Module</i>", "params": ["*", "*", "*"], "run": @BAM["handle"], "cb": null, "usage": "wip, intended to be used to launch binaries instead of using file transfer" }, 
    { "name": "eel", "desc": "Extended Rshell - Interface", "params": ["-l|-p|--"], "run": @Eel["handle"], "cb": "result", "usage": "-l --> extended rshell-interface menu\n-p --> wip plant feature\n-- --> wip info collection" },
    { "name": "tsunami", "desc": "[ip][user][port][protocol] brute force connection", "params": ["*", "*", "*", "*"], "run": @Brute["ssh"], "cb": "result", "usage": null },
	{ "name": "shellfish", "desc": "local shell brute force", "params": ["*", "*", "*"], "run": @Brute["shell"], "cb": "result", "usage": null },
	{ "name": "mailfish", "desc": "NPC mail brute force", "params": ["*"], "run": @Brute["mail"], "cb": null, "usage": null },
	{ "name": "wifish", "desc": "[bssid] [essid] Wifi brute force", "params": ["*", "*"], "run": @Brute["wifi"], "cb": null, "usage": null },


	// fin
	{ "name": "exit", "desc": "Exit Surf Mode", "params": [], "run": null, "cb": "EXIT", "usage": null },
]
//////////////////////////////////////////////////////////////  
///======================= Modules =======================///
////////////////////////////////////////////////////////////

// ><> ><> ><> ><> VARIABLES ><> ><> ><> ><>
base_shell = new ShellObject
base_shell.init()

base_pc = new CompObject
base_pc.init(get_shell.host_computer)

base_file = new FileObject
base_file.init(get_shell.host_computer.File("/"))

globals.Shells = [ [base_shell, "MAIN"] ] // our collection of global shell objects
globals.Computers = [ [base_pc, "MAIN"] ] // our collection of global computer objects
globals.Files = [ [base_file, "MAIN"] ] // our collection of global file objects
//globals.Exploits = [] // our collection of global exploit objects
globals.Global_Path = "/home" // our mutable path for 1 or more? objects

globals.Current_Path = current_path // a path for more specific commands
globals.anonymous = false

Current_Shell = get_shell // mutable shell
Current_Computer = @host_computer // well see how it goes

// ATTACKS 
fwd_machines = [] // collection of machines from a probe with open, fwd ports
local_machines = [] // machines found by ping

// MISC
color = {}
color.white = "<color=#FFFFFF>";color.grey = "<color=#A5A5A5>";color.blue = "<color=#003AFF>";
color.cyan = "<color=#00FFE7>";color.purple = "<color=#D700FF>";color.red = "<color=#AA0000>";
color.yellow = "<color=#FBFF00>";color.orange = "<color=#FF8701>";color.green = "<color=#00ED03>";
color.fill = "><> ><> ><> ><> ><> ><> ><> ><> ><> ><> ><> ><>"
color.cap = "</color>"
title = "<color=#00FFE7>[<b>SeaShell</b>]</color> "
init = "<color=#00ED03>[SeaShell] <b>init:</b></color> "
error = "<color=#AA0000>[SeaShell] <b>Error:</b></color> "
warning = "<color=#FF8701>[SeaShell] <b>Warning:</b></color> "
// ><> ><> ><> ><> LIBRARIES ><> ><> ><> ><>
meta = null
dirs = ["/lib/metaxploit.so", "/lib/cheese/metaxploit.so",current_path+"/metaxploit.so",launch_path+"/metaxploit.so",home_dir+"/metaxploit.so","/home/guest/metaxploit.so"]
for d in dirs
	meta = include_lib(d)
	if meta then break
end for
if not meta then exit(warning+color.red+"<b> metaxploit.so was not found")
dirs = ["/lib/crypto.so", "/lib/cheese/crypto.so",current_path+"/crypto.so",launch_path+"/crypto.so",home_dir+"/crypto.so","/home/guest/crypto.so"]
crypto = null
for d in dirs
	crypto = include_lib(d)
	if crypto then break
end for
if not crypto then print(warning+color.orange+" crypto was not found")
// ><> ><> ><> ><> ><> ><> ><> ><>
// ><> ><> ><>  UTILS  ><> ><> ><>
// ><> ><> ><> ><> ><> ><> ><> ><>
Utils = {}

Utils.handle = function(object)
	if (object isa ShellObject) == true then object = object.shell
	if (object isa CompObject) == true then object = object.PC
	if (object isa FileObject) == true then object = object.F
	return object
end function


//////////////////////////////////////////////////////////////  
///==================== USERS =======================////
////////////////////////////////////////////////////////////

////////////////////////////// USER /////////////////////
Utils.user = function(object)
	object = Utils.handle(object)
	if typeof(object) == "shell" or typeof(object) == "ftpshell" then object = object.host_computer
	if not object then return print("User check error, no object found")
	if object.File("/root").has_permission("r") and object.File("/root").has_permission("w") and object.File("/root").has_permission("x") then return object.File("/root").name
	if object.File("/home") == null then return "unknown"
	for f in object.File("/home/").get_folders
    	if f.name=="guest" then continue
		if f.has_permission("r") and f.has_permission("w") and f.has_permission("x") then return f.name
  	end for
  	return "guest" 
end function
/////////////////////////////// IS ROOT //////////////////////
Utils.is_root = function(object)
	object = Utils.handle(object)
	file = object.File("/root")
	if not file then file = object.File("/")
	return file.has_permission("r") and file.has_permission("w") and file.has_permission("x")
end function
///////////////////////////// CHANGE PW ////////////////////
Utils.change_pw = function(object, user="root", password)
	object = Utils.handle(object)
	if typeof(object) == "shell" then object = object.host_computer
	inputMsg = "Changing password for user " + user +".\nNew password:"
	inputPass = user_input(inputMsg, true)
	output = object.change_password(user, inputPass)
	return output
end function
//////////////////////////////////////////////////////////////  
///==================== FILESYSTEM =======================////
////////////////////////////////////////////////////////////
Utils.pth = function(p, obj = Current_Shell)
	print(p)
	if p[0] != "/" and Current_Path != "/" then p = Current_Path+"/"+p
	if p[0] != "/" and Current_Path == "/" then p = Current_Path+p
	if p == "./" and Current_Path != "/" then 
		parse = p.split("/")
		print(parse)
		p = parse[0]+"/"
	end if
	print(p)
	return p
end function
//////////////////////////////////// DEHASH ///////////////////////////
Utils["cipher"] = function(_, userPass)
	password = crypto.decipher(userPass)
	print(password)
	return password
end function
//////////////////////////////////// FILE DEHASH ///////////////////////////
Utils["decrypt"] = function(shell, file_path)
	object = Utils.handle(shell)
	if typeof(object) == "shell" then object = object.host_computer.File(file_path)
	if typeof(object) == "computer" then object = object.File(file_path)
	if not object then exit("decipher: can't find " + file_path)
	if object.is_binary then exit("decipher: can't read " + file_path + ". Binary file")
	if not object.has_permission("r") then exit("decipher: can't read file. Permission denied")
	if object.get_content.len == 0 then exit("decipher: no users found")
	lines = object.get_content.split("\n")
	if lines.len == 1 then
		userPass = lines[0].split(":")
		password = GetPassword(userPass)
	else
		print("Multiple users found.")
		numLine = 1
		for line in lines
			if line.len > 0 then
				print(numLine + ": " + line)
				numLine = numLine + 1
			end if
		end for
		option = ""
		inputOk = false
		while( not inputOk )
			option = user_input("Select user: ").to_int
			if typeof(option) != "number" or (option < 1 or option > lines.len) then
				print("Invalid input. Type a valid number")
			else 
				inputOk = true
			end if
		end while
		userPass = lines[option - 1].split(":")
		print("Selected user: " + userPass[0] + "\nDeciphering...")
		password = GetPassword(userPass)
		print(password)
		return password
end if
end function
//////////////////////////////////// WIPE (handler) ///////////////////////////
Utils["wipe"] = function(obj, param)
	if param == "-l" then 
		Utils.wipe_logs(obj)
	else if param == "-t" then 
		Utils.clean_sys(obj)
	else if param == "-s" then 
		//Utils.wipe_sys(obj)
	else 
		return 
	end if
end function
//////////////////////////////////// TOOL TRANSFER ///////////////////////////
Utils["transfer_tools"] = function(obj, eel_only = null)
	print(init+" mounting . . .")
	obj = Utils.handle(obj)
    files = []
    filenames = ["metaxploit.so", "crypto.so", "payload", "eel", "ss"]
    if eel_only == "-e" then filenames = ["metaxploit.so","eel"]
	dirs = ["/lib/", "/bin/", parent_path(launch_path) + "/", parent_path(program_path) + "/", launch_path+"/", "/lib/cheese/", "/home/guest/"]
    // if you chmod your system you will likely run into errors running this from home pc as non root
	for filename in filenames
		if globals.debug then print(color.white + "attempting "+filename)
        for dir in dirs
			str = dir+filename
			f = get_shell.host_computer.File(str)
            if f then
				if globals.debug then print("Found: "+ dir+filename)
                files = files + [dir + filename]
                break
            end if
        end for
    end for
	if files.len == 0 then print(color.orange+"Error: Cannot get files for transfer.")
    if files.len == 0 then return false
    for file in files
        get_shell.scp(file, "/home/guest", obj)
        wait(0.1)
    end for
    // Chown files
    pc = obj.host_computer
    for filename in filenames
        file = pc.File("/home/guest/" + filename)
        if not file then continue
        file.set_owner("guest")
    	file.set_group("guest")
    	wait(0.1)
	end for
	return true
end function

//////////////////////////////////// TOOL WIPE ///////////////////////////
Utils.clean_sys = function(obj)
	print(init+" wiping tools from system . . .")
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	files = ["ss", "eel", "payload", "metaxploit.so", "crypto.so"]
	dirs = ["/home/guest", "/bin"]
	home_folders = null
	for dir in dirs
		for file in files
			f = obj.File(dir+"/"+file)
			if f then
				n = f.name 
				print(color.yellow+"Deleting: "+f.path)
				del = f.delete
				wait(0.1)
				if del.len < 1 then print(color.green+"Deleted <b>"+n)
			end if
		end for
	end for
end function
//////////////////////////////////// LOG WIPE ///////////////////////////
Utils.wipe_logs = function(obj)
	print(init+" wiping system . . .")
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	
	corrupt = obj.File(home_dir+"/anonymous.dat")
	if corrupt == null then corrupt = obj.File("/home/guest/anonymous.dat")
	if corrupt == null then 
		res = obj.touch("/home/", "fish.txt")
		wait(0.5)
		file = null
		copied = null
		if res != 1 then 
			file = obj.File("/home/fish.txt")
			if file == null then return print(warning+" b8 file wasnt found")
			file.set_content(char(10)+char(10)+char(10)+char(10)+char(10)+char(10)+"><>")
			wait(0.1)
			copied = file.move("/var/", "system.log")
			status = color.yellow+"wiped"+color.cap
		else 
			corrupt = obj.File("/etc/fstab")
			if corrupt == null then return print(warning+" fstab wasnt found")
			copied = corrupt.copy("/var/", "system.log")
			corrupt.set_content(char(10)+char(10)+char(10)+char(10)+char(10)+char(10)+"><>")
			status = color.green+"corrupted"+color.cap
		end if
	else 
		corrupt.set_content("\n\n\n\n\n\n\n                          ><>")
		wait(0.1)
		copied = corrupt.move("/var/", "system.log")
		status = color.green+"corrupted"+color.cap
	end if
	if copied != 1 then print(warning+" -- Unable to wipe the system logs --")
	if copied == 1 then print(title+" system.log was [ "+status+" ] !")
	return copied
end function

Utils.wipe_sys = function(object)
	obj = Utils.handle(obj)
	if Utils.user(obj) != "root" then return print("You must run as root.")
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	confirm = user_input(color.red+"<b>=== Confirm PWN ===\n{"+color.white+obj.public_ip+color.cap+":"+color.yellow+obj.local_ip+color.cap+"}\n"+color.orange+"<b>** YOU CANNOT UNDO THIS ** \n--> ")
	if confirm != "2na" then return
	pc = get_shell.host_computer
	logfile = pc.File("/var/system.log")
	if not logfile then exit("Log file not found.")
	logfile.copy("/home/guest", "system.log")

	filenames = ["System.map", "initrd.img", "kernel.img"]
	for filename in filenames
		file = pc.File("/boot/" + filename)
		if not file then continue
		file.delete
		wait(0.1)
	end for
	filenames = ["xorg.sys", "config.sys", "network.cfg"]
	for filename in filenames
		file = pc.File("/sys/" + filename)
		if not file then continue
		file.delete
		wait(0.1)
	end for

	file = pc.File("/home/guest/ss")
	if file == null then print(file.name+" doesn't exist.")
	file.delete
	logfile = pc.File("/etc/fstab")
	if logfile != null then
		logfile.set_content(char(10)+char(10)+char(10)+char(10)+"><>")
		wait(0.1)
		logfile.move("/var", "system.log")
		print("Log file replaced.")
	else
		exit("Log doesn't exist. Clear logs...")
	end if
	print("Please reboot the machine now.")

end function

//////////////////////////////////////////////////////////////  
///==================== CONNECTION =======================////
////////////////////////////////////////////////////////////
//////////////////////////////////// WHOIS ///////////////////////////
Utils.who = function(ip)
	if is_lan_ip(ip) then return
	info = whois(ip)
	parse = info.split("\n")
	domain = parse[0].split(":")[1]
	admin = parse[1].split(":")[1]
	email = parse[2].split(":")[1]
	phone = parse[3].split(":")[1]
	print(color.blue+color.fill+"\nDomain: "+color.white+domain+color.cap+"\n"+"Admin: "+color.red+admin+color.cap+"\n"+"Email: "+color.white+email+color.cap+"\n"+"Phone: "+color.white+phone+color.cap+"\n"+color.blue+color.fill)
end function
//////////////////////////////////// CONNECT ///////////////////////////
Utils.connect = function(object, username = "root", password, addr, port)
	if not object then object = globals.Current_Object
	object = Utils.handle(object)
	if typeof(object) == "computer" then object = get_shell
	choose_type = user_input(color.green+"[ SELECT ]"+color.white+" 1.) SSH  "+color.cap+color.grey+"2.) FTP"+color.cap+"  --> "); choose_type=choose_type.val
	choose_port = user_input(color.grey+"[ ENTER ]"+color.white+" Port for connection"+color.cap+color.grey+" *use 0 for entry port*"+color.cap+" -->  ").to_int
	//choose_port = choose_port.val
	if choose_port != 0 then port = choose_port
	if choose_type == 1 then
		connection = object.connect_service(addr, port, username, password)
		protocol = "ssh"
	else 
		connection = object.connect_service(addr, port, username, password, "ftp")
		protocol = "ftp"
	end if
	print(init+color.white+" attempting remote shell connection via: "+color.grey+protocol)
	if typeof(connection) != "shell" and typeof(connection) != "ftpshell" then 
		return print(warning+color.green+"[ "+protocol+" ] "+color.cap+color.grey+" connection failed at port: "+color.white+port)
	else
		print(color.blue+color.fill)
		print(title+color.green+" [ "+color.white+typeof(connection)+color.cap+" ] ShellObject connection OK !")
		print(color.blue+color.fill)
		print("CONNECTION IP:"+ connection.host_computer.public_ip)
	end if

	return connection
end function

//////////////////////////////////////////////////////////////  
///====================== MISC =========================////
////////////////////////////////////////////////////////////
Utils.random_ip = function()
    while true //loop
        ip = floor((rnd * 255) + 1) + "." + floor((rnd * 255) + 1) + "." + floor((rnd * 255) + 1) + "." + floor((rnd * 255) + 1) //Generate a random ip
        if not is_valid_ip(ip) then continue //If the ip is invalid, try again
        if is_lan_ip(ip) then continue //If the ip is a lan ip, try again
		//if not get_router(ip) then continue //do not check for this cause most of the time there will be a router and this slows down the process A LOT
        return ip //If the ip is valid, break out of the loop
    end while
end function
//////////////////////////////////// RANDOM PLAYER IP ///////////////////////////
Utils.player_ip = function(p = 1222)
	print("Fishing for Player IP: . . . ><> . . . ><> . . . ><>")
    while true //loop
        ip = floor((rnd * 255) + 1) + "." + floor((rnd * 255) + 1) + "." + floor((rnd * 255) + 1) + "." + floor((rnd * 255) + 1) //Generate a random ip
        if not is_valid_ip(ip) or is_lan_ip(ip) then continue //If the ip is invalid, try again
		r = get_router(ip);if not r then continue;ports = r.used_ports
		if ports.len == 0 then continue;
			for port in ports
				if port.port_number == p then return ip
			end for
		//end for 
    end while
end function 
welcome_msg = function()
	print("       .               "+color.red+"               __..._")
	print("      ':'              "+color.red+"           ..-'      o.")
	print("    ___:____     |'\/'|"+color.red+"         .-'           :")
	print("  ,'        `.    \  / "+color.red+"      _..'           .'__..--<")
	print("  |  O        \___/  | "+color.red+"...--""              '-.")
	print("~^~^~^~^~^~^~^~^~^~^~^~"+color.red+"^~^~^~^~^~^~^~^~^~^~^~^~")
	print(color.blue+color.fill)
	print(color.red+ ".                                            /\")
	print(color.cyan+"   _____            </color><color=#AA0000> _____ _          _ _   {.-}")  
	print(color.cyan+"  / ____|           </color><color=#AA0000>/ ____| |        | | | ;_.-'\") 
	print(color.cyan+" | (___   ___  __ _</color><color=#AA0000>| (___ | |__   ___| | |{    _.}_") 
	print(color.cyan+"  \___ \ / _ \/ _` |</color><color=#AA0000>\___ \| '_ \ / _ \ | | \.-' /  `,") 
	print(color.cyan+"  ____) |  __/ (_| |</color><color=#AA0000>____) | | | |  __/ | |  \  |    /") 
	print(color.cyan+" |_____/ \___|\__,_|</color><color=#AA0000>_____/|_| |_|\___|_|_|   \ |  ,/")
	print(color.red+".                                             \|_/")
	print(title+" </color><color=#00ED03>- v1.0.1 - Made with <3 by</color><color=#00FFE7> Tuna Terps" )
	print(color.blue+color.fill)
end function

Utils.got_rooted = function()
	print(color.green+"                                   ____")
	print(color.green+"                               /\|    ~~\")
	print(color.green+"                             /'  |   ,-. `\")
	print(color.green+"                            |       | X |  |")
	print(color.green+"                           _|________`-'   |X")
	print(color.green+"                         /'          ~~~~~~~~~,")
	print(color.green+"                       /'             ,_____,/_")
	print(color.green+"                    ,/'        ___,'~~         ;")
	print(color.green+"~~~~~~~~|~~~~~~~|---          /  X,~~~~~~~~~~~~,")
	print(color.green+"        |       |            |  XX'____________'")
	print(color.green+"        |       |           /' XXX|            ;")
	print(color.green+"        |       |        --x|  XXX,~~~~~~~~~~~~,")
	print(color.green+"        |       |          X|     '____________'")
	print(color.green+"        |   o   |---~~~~\__XX\             |XX")
	print(color.green+"        |       |          XXX`\          /XXXX")
	print(color.green+"~~~~~~~~'~~~~~~~'               `\xXXXXx/' \XXX")
	print(color.green+"                                 /XXXXXX\")
	print(color.green+"                               /XXXXXXXXXX\")
	print(color.green+"                             /XXXXXX/^\X2NAXX\")
	print(color.green+"                            ~~~~~~~~   ~~~~~~~")
end function

Utils.scuba_msg = function()
	print(color.blue+"                                   __")
	print(color.blue+"                                  |::|")
	print(color.blue+"                                  |::|")
	print(color.blue+"                 _..---.._        |::|")
	print(color.blue+"               .' /     \ `.      |::|")
	print(color.blue+"              /  /       \  \     |::|")
	print(color.blue+"             /  /         \  \    |  |")
	print(color.blue+"            /   |         |   \   |  |")
	print(color.blue+"           |    |   ___   |    |  |  |")
	print(color.blue+"  _`'..._-.|____|__|\\/|__|____|..|  | ___")
	print(color.blue+"  ____...  | .- - - - - - - -. | .|  |_   `'")
	print(color.blue+"    ____.  /.-----------------.\ .|  | ```..")
	print(color.blue+"``..      //'  `-._     _.-`  '\\ |  | ..")
	print(color.blue+"    ...-' ||'  /.-.\   /.-.\  '|| `..\...`'`")
	print(color.blue+"   ---._` \\:_ \("+color.red+"o"+color.cap+color.blue+")/...\("+color.red+"o"+color.cap+color.blue+")/._:// .----..---")
	print(color.blue+"    ___.._  __....   ._....._.....___")
	print(color.blue+"'' ___.._  __....   ._....._.....___")

end function
Utils.fish_tank_msg = function()
	print(color.blue+"|  \|/  *    .  .    . .. .      |")
	print(color.blue+"|   \|*/*     ..     _ . .       |")
	print(color.blue+"|   *|| |     ..   ><_> . _      |")
	print(color.blue+"|   |`|/     _ .         <_><    |")
	print(color.blue+"|    \|    ><_>              _   |")
	print(color.blue+"`-----!---------!!!---!!!---/ \--'")
end function
Utils.paired_msg = function()
	print(color.white+"   _______________                        |*\_/*|________")
	print(color.white+"  |  ___________  |     "+color.red+".-.     .-."+color.cap+color.white+"      ||_/-\_|______  |")
	print(color.white+"  | |           | |    "+color.red+".****. .****."+color.cap+color.white+"     | |           | |")
	print(color.white+"  | |   "+color.green+"0   0"+color.cap+color.white+"   | |    "+color.red+".*****.*****."+color.cap+color.white+"     | |   "+color.red+"0   0"+color.cap+color.white+"   | |")
	print(color.white+"  | |     -     | |     "+color.red+".*********."+color.cap+color.white+"      | |     -     | |")
	print(color.white+"  | |   \___/   | |      "+color.red+".*******."+color.cap+color.white+"       | |   \___/   | |")
	print(color.white+"  | |___     ___| |       "+color.red+".*****."+color.cap+color.white+"        | |___________| |")
	print(color.white+"  |_____|\_/|_____|        "+color.red+".***."+color.cap+color.white+"         |_______________|")
	print(color.white+"    _|__|/ \|_|_"+color.red+"............"+color.red+".*.............."+color.cap+color.white+"_|________|_")
	print(color.white+"   / ********** \                          / ********** \")
	print(color.white+" /  ************  \                      /  ************  \")
	print(color.white+"--------------------                    --------------------")
end function
//////////////////////////////////////////////////////////////  
///====================== UI =========== ================////
////////////////////////////////////////////////////////////
// exploitmenu.src 
// a multi-page menu desisgned to handle
// 1.) net session exploits
// 2.) local elevation 
// 3.) router penetration selected_menu = 0


// *******
//* Attack = function 
//* shells: list [ [shell_type, shell_object: Shell] ]
//* computers: list [ [ computer: Computer ] ]
//* files: list [ [ file: File ] ]
//* others: list [ [ file: String | Number ] ]
//* returns [exploit_type: Number, exploit_object: Map ]
exploit_menu = function(shells, comps, files, others)
	selected_option = 0
	selected_exploit = null
	selecting = true
	options = []
	if shells.len == 0 and comps.len == 0 and files.len == 0 and others.len == 0 then return print("Error, no exploits passed to the menu"); 
	print(color.blue+color.fill);print(init+color.green+" entering exploit menu . . .");print(color.blue+color.fill);
	while selecting == true	
		
		if selecting == false then break
		menu = [color.white+"~^~^~^~ Main ~^~^~^~"+color.cap, color.purple+"~^~^~^~ Shells ~^~^~^~"+color.cap, color.blue+"~^~^~^~ Computers ~^~^~^~"+color.cap, color.green+"~^~^~^~ Files ~^~^~^~"+color.cap, color.grey+"~^~^~^~ Other ~^~^~^~"+color.cap]
		if selected_menu == 0 then options = ["Shells: "+shells.len, "Computers: "+comps.len, "Files: "+files.len, "Other: "+others.len]
		// ASSIGNMENT
		if selected_menu == 1 then options = shells 
		if selected_menu == 2 then options = comps
		if selected_menu == 3 then options = files
		if selected_menu == 4 then options = others
		chosen_exploit = null
		in_main = null
		count = 1
		choices = menu[selected_menu]
		// FORMAT CHOICES
		for o in options
			info = ""
			if count == 3 and selected_menu == 3 then info = "NAME OWNER GROUP SCOPE PERMS"
			if selected_menu == 0 then
				info = info+o
				in_main = true
			else if selected_menu == 1 then		// shell exploit
				c = color.white
				u = Utils.user(o.shell)
				if @u == "root" then c = color.green
				if @u == "guest" then c = color.orange
				if @u == "unknown" then c = color.red
				info = "[ " +c+ u +color.cap+ " ] "
				in_main = false
			else if selected_menu == 2 then		// computer exploit
				c = color.white
				u = Utils.user(o.PC)
				if @u == "root" then c = color.green
				if @u == "guest" then c = color.orange
				if @u == "unknown" then c = color.red
				info = "[ " +c+ u +color.cap+ " ]<s>   </s>{" +color.white+o.ip+color.cap+":"+color.grey+o.lan+color.cap+"}"
				//info = "[_" + Utils.user_check(o) + "_]"
				in_main = false
			else if selected_menu == 3 then 		// file exploit
				lvl=""
				if o.F.has_permission("r") then lvl = lvl+"r"
				if o.F.has_permission("w") then lvl = lvl+"w"
				if o.F.has_permission("x") then lvl = lvl+"x"
				info = format_columns(o.F.name+" "+o.F.owner+" "+o.F.group+" "+lvl+" "+o.F.permissions)
				in_main = false
			else if selected_menu == 4 then
				info = o
				in_main = false
			end if
			if options.len == 0 then 
				info = "No exploits found"
				continue
			end if
			choices = choices+"\n"+count+".) "+info
			count = count+1
	end for
		if count == 1 then
			selected_menu = 0 
			continue
		end if
		
		print(choices)
		//print("0._Return to Main")
		choice_response = null
		if in_main == true or selected_menu == 0  then 
			menu_response = user_input(color.red+"<b>SELECT MENU</b>"+color.cap+color.grey+" * exit to Return *"+color.cap+color.white+" --> ")
			if menu_response == "exit" then 
				selecting = false
				return null
			end if
			selected_menu = menu_response.val
		end if
		if selected_menu == 0 and in_main == false then return
		if selected_menu > 0 and in_main == false then 
			choice_response	= user_input(color.orange+"<b>CHOOSE OPTION</b> "+color.cap+color.grey+"* 0 to return*"+color.cap+color.white+" --> ")
			if choice_response.val == 0 then 
				selected_menu = 0
				continue
			end if 
			if choice_response.val > options.len then continue
			if choice_response.val == 0 then selected_menu = 0

			attack_choice = user_input(color.yellow+"<b>CONFIRM</b> "+color.cap+color.white+"* Press 1 to use exploit"+color.cap+color.grey+" * Press any to return *"+color.cap+color.white+" --> ")
			attack_choice = attack_choice.val
			if attack_choice == 1 then
				chosen_exploit = options[choice_response.val-1] 
				selected_exploit = chosen_exploit
				selecting = false
				return [selected_menu, selected_exploit]
			end if
		end if
	end while
	print("exiting attack loop . . .")
end function




GFX = {}
GFX.f=function(l)
    x=10
    y=24
    out=""
    while l.len>0
        scale=1
        obj=l[0]
        text=obj.indexes[0]
        vals=obj[text]
        rot=-vals[2]
        torot=""
        toscale=""
        if scale!=1 then toscale="<size="+(scale*100)+"%>"
        torot="<rotate="+(rot)+">"
        tox="<pos="+((vals[0]*x)*scale)+">"
        toy="<voffset="+((-vals[1]*y)*scale)+">"
        if vals[3]==1 then
            num=0
            for let in text
                ang=(rot*(pi/180))
                posx=(cos(ang)*num)*10
                posy=(sin(ang)*num)*10
                out=out+toscale+torot+"<pos="+(((vals[0]*x)*scale)+posx)+"><voffset="+(((-vals[1]*y)*scale)+posy)+">"+let
                num=num+1
            end for
        else
            out=out+toscale+torot+tox+toy+text
        end if
        l.pull
    end while
    return out
end function

//print f(l)

// Starting from left, going right:
// 
// X Position
// Y Position
// Rotate
// Whole Word
// 
// X, will move it horizontally
// Y, will move it vertically
// Rotate, will rotate it
// Whole Word, will decide whether you want to rotate the whole string or just the letters
// 
// For personal preferences, I inverted the rotate value so negative values will go anti-clockwise instead

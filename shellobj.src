import_code("/home/2NA/source/binary")

// shellobject -> create mutable instances of each exploit object
//////////////////////////////////////////////////////////
//////////////////////// INIT  ///////////////////////////
/////////////////////////////////////////////////////////
Global_Shells = [] // primitive list for handling multiple shells ?
Mut_Shell = null // this is a shell that we will use for handling and throwing away shells 

ShellObject = {}
ShellObject.user = "unknown"
ShellObject.pass = "pass"
ShellObject.type = "base"
ShellObject.fs = {}

ShellObject.init = function(shell=null, user=null, pass=null, type=null)
	if shell then self.shell = shell
	if not shell and user and pass then self.shell = get_shell(user, pass)
	if not shell and not user then self.shell = get_shell

	if type then self.type = type
	
	self.pc = self.shell.host_computer
	self.ip = self.shell.host_computer.public_ip
	self.lan = self.shell.host_computer.local_ip

	self.is_root = self.shell.host_computer.File("/root").has_permission("r") and self.shell.host_computer.File("/root").has_permission("w") and self.shell.host_computer.File("/root").has_permission("x")
	self.dict = self.shell.host_computer.File("/home")	
end function
// path: string, filename: string
ShellObject.getType = function(p, f="anonymous.dat")
	self.user = "guest"
	if not self.pc then return print("error")
	file = self.pc.File(p+"/"+f)
	if file == null then
		response = user_input("enter new filename\n--> ") 
		self.pc.touch(p, response)
		if self.pc.File(p+"/"+response) != null then	 
			wait(0.1)
			print(self.pc.File(p+"/"+response))
			if self.pc.File(p+"/"+response).has_permission("r") then return self.pc.File(p+"/"+response).owner
			self.user = self.pc.File(p+"/"+response).owner
		else 
			print("Error: no permissions for directory")
			self.user = "guest"
		end if 
	end if
	return self.user
end function

/////////////////////////////////////////////////////////
/////////////////////  UTILITY *redundant*   ///////////
///////////////////////////////////////////////////////
// =======================  cd =======================
ShellObject.cd = function(p=null)
	if not p then dir = self.pc.File(self.home)
	if p then dir = self.pc.File(p)
	if dir == null then return print(warning+" No directory found")
	self.dict = p
	return self.dict
end function

// =======================  ls =======================
ShellObject.ls = function(p)
	print(init+" fs: "+color.white+p)
	folder_path = p
	if not p then folder_path = current_path
	folder = self.pc.File(folder_path)
	if folder == null then return print("ls no file or directory found")
	if not folder.has_permission("r") then return print("You do not have read access for "+folder)
	sub_files = folder.get_folders + folder.get_files
	output = ""
	for f in sub_files
		if output.len > 0 then output = output + "\n"
		file_name = f.name; permission = f.permissions
		output = output + permission + " " + f.owner + " " + f.group + " " + f.size + " 00:00 " + file_name
	end for
	print(format_columns(output))
end function
// =======================  ps =======================
ShellObject.ps = function()
	output = self.pc.show_procs
	return print(format_columns(output))
end function
// =======================  kill =======================
ShellObject.kill = function(pid)
	if typeof(pid) != "number" then return print(warning+" The PID must be a number\n")
	output = self.pc.close_program(pid)
	if output == true then return print("Process " + pid + " closed");
	if output then return print(output)
	print("Process " + pid + " not found")
end function
// =======================  pw =======================
ShellObject.pw = function(user)
	inputMsg = "Changing password for user " + user +".\nNew password:"
	inputPass = user_input(inputMsg, true)
	output = self.pc.change_password(user, inputPass)
	self.pass = inputPass
	if output == true then return print(user+" password modified OK")
	if output then return print(output)
	print(warning+" password not modified, are you root?")
end function

// =======================  sudo =======================

ShellObject.sudo = function(arg, arg2=null, arg3=null)
	computer = self.pc
	inputPass = user_input("Password: ", true)
	s = new ShellObject
	if arg == "-u" then 
		s.init(self.shell)
	else
		s.init(self.shell, "root". inputPass, "root")
	end if
	if not s then return print(color.orange+"AUTH FAIL")
	if arg == "-l" then 
		program = self.pc.File(arg2)
		if not program then return print(arg2 + " not found.")
		if not arg3 then s.shell.launch(arg2)
		if arg3	then s.shell.launch(arg2, arg3)
	end if
	if s then
		print(color.green+" AUTH OK ") 
		confirm = user_input("1.) Terminal\n2.) Surf Mode\n3.) Exit\n--> ")
		if confirm.val == 1 then return s.shell.start_terminal
		if confirm.val == 2 then return s.shell.launch(launch_path, "-s")
	end if
	return s
end function
// =======================  chmod =======================
ShellObject.ch = function(shell, recursive, perms, path_to_file)
	file = shell.host_computer.File(path_to_file)
	if file == null then return print("cannot find file "+path_to_file)
	output = file.chmod(perms, recursive)
	if output then print(output)
end function


/////////////////////////////////////////////////////////
/////////////////////   ATTACKS  ////////////////////////
/////////////////////////////////////////////////////////


ShellObject.pw_attack = function(net = null)
	print(color.purple+"[S]"+color.white+" attempting simple password change . . .") 
	password = null
	password = user_input("Enter a new password: ", true)
	pw_change = self.pc.change_password("root", password)
	wait(0.1)
	if pw_change == 1 then
		print(color.green+"-- auth change OK !  --> "+password)
	else
		print(color.grey+"-- auth change Failed !  --> "+color.cap+" attempting to access /etc/passwd . . .")
		file = self.pc.File("/etc/passwd")
		if not file then return print(color.yellow+"Error: Cannot get passwd file.")
		if not file.has_permission("r") then return print(color.red+"/etc/passwd: Permission denied.") 
		if file.is_binary or file.is_folder then return print(color.purple+"File is either binary or a folder.")
		roothash = file.get_content.split("\n")[0].split(":")[1]
		if not roothash then return print(color.red+"Error: Cannot get root hash.")
		if not crypto then crypto = include_lib("/home/guest/crypto.so")
		if not crypto then return print(color.red+"[ Warning ] Crypto Not Found")
		password = crypto.decipher(roothash)
		if not password then return print(warning+"Error: Failed to decrypt root password.")
		print("><> ><> Root Shell Obtained ! ><> ><> \nUser: root\nPass: " + password)
	end if
	if not net then
		root_shell = new ShellObject
		//connect = user_input(color.white+"* Press 1 to connect a net shell *"+color.cap+color.grey+" * Press any to return root shell * "+color.cap+"--> ") 
		//connect = connect.val
		//if connect == 1 then 
			//connect = Utils.connect(null, "root", password, addr, port)
			//if root_shell != null then root_shell.init(connect)
		//end if
		//if connect != 1 then root_shell = password
		root_shell.init(null, "root", password)
	else 
		root_shell = password
	end if
	
	return root_shell
end function

///////////////////////////////// CHMOD /////////////////////////////////
ShellObject.chmod_attack = function(file = "/", user = "guest", perms = "o+wrx")
	if self.pc.File(file) == null then return(warning+"couldnt find "+ file)
	ch_attempt = self.pc.chmod(perms, true)
	ow_attempt = self.pc.set_owner(user)
	gr_attempt = self.pc.set_group(user)
	wait(0.1)
	if ch_attempt.len < 1 then print(self.F.name+" was given scope of"+perms)
	if ow_attempt.len < 1 then print(self.F.name+" is now owned by "+user)
	if gr_attempt.len < 1 then print(self.F.name+" has the group of "+user)
end function

///////////////////////////////// PWN /////////////////////////////////
ShellObject.sys_pwn = function()
	dirs = ["/boot", "/sys", "/"]
	for dir in dirs
		file = self.pc.File(dir)
		if file == null then continue
		if file.is_folder then 
			for f in file.get_files
				print("attempting deletion of: "+f.name)
				fd = f.delete
				wait(0.1)
				if fd.len == 0 then print("deletion --> OK") 
			end for
			print("attempting deletion of: "+file.name)
			fdel = file.delete
			wait(0.1)
			if fdel == 0 then print("deletion --> OK") 
		else 
			print("attempting deletion of: "+file.name)
			fdel = file.delete
			wait(0.1)
			if fdel == 0 then print("deletion --> OK") 
		end if 
	end for
end function


//print("===========================================================")
// =======================  TEST CASES =======================
//test_shell = get_shell
//print(test_shell isa ShellObject)

//shell_obj = new ShellObject
//shell_obj.init()
//print(shell_obj isa ShellObject)
//print("shell? "+typeof(shell_obj))
//print("shell.shell? "+typeof(shell_obj.shell))

//print("===========================================================")

//shell_obj_2 = new ShellObject
//shell_obj_2.init(test_shell)
//print(shell_obj_2 isa ShellObject)
//print("shell? "+typeof(shell_obj_2))
//print("shell.shell? "+typeof(shell_obj_2.shell))

//print("===========================================================")

//shell_obj_3 = new ShellObject
//shell_obj_3.init(null, "root", pass, "root")
//print(shell_obj_3 isa ShellObject)
//print("shell? "+typeof(shell_obj_3))
//print("shell.shell? "+typeof(shell_obj_3.shell))

//print("===========================================================")

//print(shell_obj.getUser("/home/guest"))
//print(shell_obj.getUser("/home/guest"))
//print(shell_obj_2.is_root)
//print(shell_obj_3.shell.launch("/bin/ss", "-s"))
//print("===========================================================")

//shell_obj_3.t

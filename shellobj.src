//import_code("/home/2NA/source/binary")

// shellobject -> create mutable instances of each exploit object
//////////////////////////////////////////////////////////
//////////////////////// INIT  ///////////////////////////
/////////////////////////////////////////////////////////
Global_Shells = [] // primitive list for handling multiple shells ?
Mut_Shell = null // this is a shell that we will use for handling and throwing away shells 

ShellObject = {}
ShellObject.user = "unknown"
ShellObject.pass = "pass"
ShellObject.type = "base"
ShellObject.fs = {}

ShellObject.init = function(shell=null, user=null, pass=null, type=null)
	if shell then self.shell = shell
	if not shell and user and pass then self.shell = get_shell(user, pass)
	if not shell and not user then self.shell = get_shell

	if type then self.type = type
	
	self.pc = self.shell.host_computer
	self.ip = self.shell.host_computer.public_ip
	self.lan = self.shell.host_computer.local_ip

	self.is_root = self.shell.host_computer.File("/root").has_permission("r") and self.shell.host_computer.File("/root").has_permission("w") and self.shell.host_computer.File("/root").has_permission("x")
	self.dict = self.shell.host_computer.File("/home")	
end function
// path: string, filename: string
ShellObject.getType = function(p, f="anonymous.dat")
	self.user = "guest"
	if not self.pc then return print("error")
	file = self.pc.File(p+"/"+f)
	if file == null then
		response = user_input("enter new filename\n--> ") 
		self.pc.touch(p, response)
		if self.pc.File(p+"/"+response) != null then	 
			wait(0.1)
			print(self.pc.File(p+"/"+response))
			if self.pc.File(p+"/"+response).has_permission("r") then return self.pc.File(p+"/"+response).owner
			self.user = self.pc.File(p+"/"+response).owner
		else 
			print("Error: no permissions for directory")
			self.user = "guest"
		end if 
	end if
	return self.user
end function

/////////////////////////////////////////////////////////
/////////////////////   UTILITY  ////////////////////////
/////////////////////////////////////////////////////////
// =======================  cd =======================
ShellObject.cd = function(p=null)
	if not p then dir = self.pc.File(self.home)
	if p then dir = self.pc.File(p)
	if dir == null then return print(warning+" No directory found")
	self.dict = p
	return self.dict
end function

// =======================  ls =======================
ShellObject.ls = function(p)
	print(init+" fs: "+color.white+p)
	folder_path = p
	if not p then folder_path = current_path
	folder = self.pc.File(folder_path)
	if folder == null then return print("ls no file or directory found")
	if not folder.has_permission("r") then return print("You do not have read access for "+folder)
	sub_files = folder.get_folders + folder.get_files
	output = ""
	for f in sub_files
		if output.len > 0 then output = output + "\n"
		file_name = f.name; permission = f.permissions
		output = output + permission + " " + f.owner + " " + f.group + " " + f.size + " 00:00 " + file_name
	end for
	print(format_columns(output))
end function
// =======================  ps =======================
ShellObject.ps = function()
	output = self.pc.show_procs
	return print(format_columns(output))
end function
// =======================  kill =======================
ShellObject.kill = function(pid)
	if typeof(pid) != "number" then return print(warning+" The PID must be a number\n")
	output = self.pc.close_program(pid)
	if output == true then return print("Process " + pid + " closed");
	if output then return print(output)
	print("Process " + pid + " not found")
end function
// =======================  pw =======================
ShellObject.pw = function(user)
	inputMsg = "Changing password for user " + user +".\nNew password:"
	inputPass = user_input(inputMsg, true)
	output = self.pc.change_password(user, inputPass)
	self.pass = inputPass
	if output == true then return print(user+" password modified OK")
	if output then return print(output)
	print(warning+" password not modified, are you root?")
end function

// =======================  sudo =======================

ShellObject.sudo = function(arg, arg2=null, arg3=null)
	computer = self.pc
	inputPass = user_input("Password: ", true)
	s = new ShellObject
	if arg == "-u" then 
		s.init(self.shell)
	else
		s.init(self.shell, "root". inputPass, "root")
	end if
	if not s then return print(color.orange+"AUTH FAIL")
	if arg == "-l" then 
		program = self.pc.File(arg2)
		if not program then return print(arg2 + " not found.")
		if not arg3 then s.shell.launch(arg2)
		if arg3	then s.shell.launch(arg2, arg3)
	end if
	if s then
		print(color.green+" AUTH OK ") 
		confirm = user_input("1.) Terminal\n2.) Surf Mode\n3.) Exit\n--> ")
		if confirm.val == 1 then return s.shell.start_terminal
		if confirm.val == 2 then return s.shell.launch(launch_path, "-s")
	end if
	return s
end function
// =======================  chmod =======================
ShellObject.ch = function(shell, recursive, perms, path_to_file)
	file = shell.host_computer.File(path_to_file)
	if file == null then return print("cannot find file "+path_to_file)
	output = file.chmod(perms, recursive)
	if output then print(output)
end function


/////////////////////////////////////////////////////////
/////////////////////   ATTACKS  ////////////////////////
/////////////////////////////////////////////////////////



ShellObject.pw_attack = function(net = null, addr = null, port = null)
	print(color.purple+"[S]"+color.white+" attempting simple password change . . .") 
	password = null
	password = user_input("Enter a new password: ", true)
	pw_change = self.pc.change_password("root", password)
	wait(0.1)
	if pw_change == 1 then
		print(color.green+"-- auth change OK !  --> "+password)
	else
		print(color.grey+"-- auth change Failed !  --> "+color.cap+" attempting to access /etc/passwd . . .")
		file = self.pc.File("/etc/passwd")
		if not file then return print(color.yellow+"Error: Cannot get passwd file.")
		if not file.has_permission("r") then return print(color.red+"/etc/passwd: Permission denied.") 
		if file.is_binary or file.is_folder then return print(color.purple+"File is either binary or a folder.")
		roothash = file.get_content.split("\n")[0].split(":")[1]
		if not roothash then return print(color.red+"Error: Cannot get root hash.")
		if not crypto then crypto = include_lib("/home/guest/crypto.so")
		if not crypto then return print(color.red+"[ Warning ] Crypto Not Found")
		password = crypto.decipher(roothash)
		if not password then return print(warning+"Error: Failed to decrypt root password.")
		print("><> ><> Root Shell Obtained ! ><> ><> \nUser: root\nPass: " + password)
	end if
	root_shell = new ShellObject
	if not net then 
		root_shell.init(null, "root", password, "root")
		Utils.paired_msg
	else
		connect = user_input(color.white+"* Press 1 to connect a net shell *"+color.cap+color.grey+" * Press any to return root shell * "+color.cap+"--> ")
		connect = connect.val
		if connect == 1 then 
			connect = Utils.connect(null, "root", password, addr, port)
			if root_shell != null then root_shell.init(connect)
		end if
		if connect != 1 then root_shell = password
	end if
	return root_shell
end function
//print("===========================================================")
// =======================  TEST CASES =======================
//test_shell = get_shell
//print(test_shell isa ShellObject)

//shell_obj = new ShellObject
//shell_obj.init()
//print(shell_obj isa ShellObject)
//print("shell? "+typeof(shell_obj))
//print("shell.shell? "+typeof(shell_obj.shell))

//print("===========================================================")

//shell_obj_2 = new ShellObject
//shell_obj_2.init(test_shell)
//print(shell_obj_2 isa ShellObject)
//print("shell? "+typeof(shell_obj_2))
//print("shell.shell? "+typeof(shell_obj_2.shell))

//print("===========================================================")

//shell_obj_3 = new ShellObject
//shell_obj_3.init(null, "root", pass, "root")
//print(shell_obj_3 isa ShellObject)
//print("shell? "+typeof(shell_obj_3))
//print("shell.shell? "+typeof(shell_obj_3.shell))

//print("===========================================================")

//print(shell_obj.getUser("/home/guest"))
//print(shell_obj.getUser("/home/guest"))
//print(shell_obj_2.is_root)
//print(shell_obj_3.shell.launch("/bin/ss", "-s"))
//print("===========================================================")

//shell_obj_3.t

//print("===========================================================")
// =======================  apt-get =======================
PendingUpdating = function(folderPath)
	pendingUpdate = []
	targetFolder = get_shell.host_computer.File(folderPath)
	if targetFolder != null then
		files = targetFolder.get_files
		for itemFile in files
			output = aptclient.check_upgrade(itemFile.path)
			if output == true then
				pendingUpdate.push(itemFile.name)
			end if
		end for
	end if
	return pendingUpdate
end function 

//  shell: Shell
// (action) p1: action: string
// (lib) p2: string | null
// (force) p3: boolean | null
// =======================  apt-get =======================
ShellObject.git = function(p1, p2=null, p3=null)
	aptclient = include_lib("/lib/aptclient.so")
	if not aptclient then
    	aptclient = include_lib(current_path + "/aptclient.so")
	end if
	if not aptclient then return print(warning+ " Missing aptclient.so library in the /lib path or the current folder")

	if p2 == null then // UPDATE
		if p1 == "-u" then 
			print("Updating package lists...")
			output = aptclient.update
			if output then print(output)
		else if p1 == "--" then //UPGRADE
			if p2 != null then 
				pendingPackages = PendingUpdating("/lib") + PendingUpdating("/bin")
				if pendingPackages.len == 0 then return print("No updates needed")
				print("The following packages will be updated:")
				pkgs = ""
				for itemPackage in pendingPackages
					pkgs = pkgs + " " + itemPackage
				end for
				print(pkgs)
				force = null
				if p3 != "-f" then 
					option = user_input("\nDo you want to continue?(y/n): ")
					if input != "y" or input != "yes" or input.val != 1 then return print("Exiting . . .")
				end if
				counter = 0
				for itemPackage in pendingPackages
					output = aptclient.install(itemPackage)
					if output == true then
						counter = counter + 1
					else if output then
						print(output)
					end if
				end for
				print(counter + " packages updated")
			else 
				output = aptclient.check_upgrade(p2)
				if not output then exit("No updates needed")
				if output == true then
					print("The following package will be updated:\nparams[1]")
					option = user_input("\nDo you want to continue?(y/n): ")
					if option == "y" or option == "yes" then
						output = aptclient.install(p2)
						if output == true then return print(p2 + " installed.")
						print(output)				
					else 
						return print("aborted")
					end if
				else 
					print(output)
				end if
			end if 
		
	else if p1 == "-i" and p2 != null then // INSTALL
		print("Reading package lists...")
		if not p2 then  
			print(command_info("apt-get_usage"))
		end if
		print("Downloading " + p2)
		output = aptclient.install(p2)
		if output == true then 
			print(p2 + " installed")
		end if
		print(output)

	else if p1 == "-s" then 
		print(aptclient.search(p2));
	else if p1 == "-sh" then 
		print(aptclient.show(p2));
	else if p1 == "-a" and p2 != null then // ADD_REPO 
		port = 1542
    	if p3 then port = p3.val
		output = aptclient.add_repo(p2)
		if output then print(output)
		print("Repository " + p2 + " added succesfully.\nLaunch apt with the update option to apply the changes")
	
	else if p1 == "-d" then // DEL_REPO
    	output = aptclient.del_repo(p2)
    	if output then print(output)
    	print("Repository " + p2 + " removed succesfully.\nLaunch apt with the update option to apply the changes")
		
	else
		print(command_info("apt-get_usage"))
	end if     
end function

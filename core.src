//////////////////////////////////////////////////////////////  
///======================= CORE =========================////
////////////////////////////////////////////////////////////
Core = {}
// object: ShellObject: Map | CompObject: Map | FileObject: Map
// global_path = out global path fool
///======================= PROMPT =========================////
Core.prompt = function(o, p, anonymous)
	user_color = color.white
	type = color.purple+"S"+color.cap 
	if (o isa ShellObject) == true then
		if typeof(o.shell) == "ftpshell" then type = color.green+"FTP"+color.cap
		o = o.shell.host_computer
	else if (o isa CompObject) == true then
		o = o.PC 
		type = color.blue+"C"+color.cap
	else if (o isa CompObject) == true then 
		type = color.green+"F"+color.cap
	else 
		return print(warning+ " Invalid prompt type")
	end if
	user = Utils.user(o)
	if @user == "root" or "2NA" then user_color = color.green
	if @user == "guest" then user_color = color.orange
	if @user == "unknown" then user_color = color.red
  	ip = o.public_ip
	lan = o.local_ip
	if anonymous == true then ip = "HIDDEN"
 	spacing = 3.9
	pc = "fish"
	spacing = spacing+(user.len+pc.len)*0.6
	str =  "\n<pos=04>—{<b>"+user_color+user+color.cap+"</b>}—[<b>"+type+"</b>]—{"+color.white + ip + color.cap+":"+color.grey + lan + color.cap+"}—[<b>"+color.white+p+color.cap+"</b>]<voffset=-0.5em><space=-"+spacing+"em><pos=00>|<voffset=-1em><space=-0.6em>|<voffset=-1.5em><pos=04>——:~"+color.white+"$"+color.cap+" " 				
	response = user_input(str)
	return response
end function
///======================= CMD =========================////
// object: ShellObject: Map | CompObject: Map | FileObject: Map
// params: List
// the most boiler plated i could think of :^)
Core.cmd = function(object, params)
	error = null
	result = null
	parse = params.split(" ")
	
	if parse.len == 1 then
		p = parse[0] 
		if is_valid_ip(p) then 
			result = Core.Probe(p)
		else if p == "-h" or p == "help" then 
			Core.cmd_list
		else if p == "-t" and (object isa ShellObject ) == true then 
			object.shell.start_terminal
		else if p == "-c" then 
			clear_screen
		else if p == "-a" then 
			if anonymous == true then globals.anonymous = false else globals.anonymous = true
		else if p == "-g" then 
			result = Core.objects
		else if p == "iam" then 
			Core.me(object)
		else if p == "ls" then 
			Core.ls(object)
		else if p == "ps" then 
			Core.ps(object)
		else if p == "cd" then
			Current_Path = Core.cd(object, null)
		else if p == "lan" then
			Core.lan
		else if p == "depot" then 
			remote_transfer(object)
		else if p == "wipe" then
			confirm = user_input(warning+"~~^~ WIPE ~~^~ \n1.) Logs\n2.) Tools\n--> ")
			confirm = confirm.val
			if confirm == 1 then Utils.wipe_log(object)
			if confirm == 2 then object.shell.launch("/home/guest/autoclean")
		else if p == "+" and (object isa ShellObject) == true then
			object.shell.launch("/home/guest/ss")
		else if p == "|" and (object isa ShellObject) == true then
			object.shell.launch("/home/guest/eel", "auth")
		else if p == "||" and (object isa ShellObject) == true then
			data = get_custom_object()
			data.so = @ShellObject
			data.root = null
			object.shell.launch("/home/guest/payload")
			if data.root != null then result = data.root
		else if p == "sf" then
			Core.sniff
		else if p == "bf" then
			Core.brute(object)
		else if p == "-r" then
			rando = Utils.random_ip
			result = Core.Probe(rando)
		else if p == "-rp" then
			rando = Utils.player_ip
			result = Core.Probe(rando)
		else if p == "exit" or p == "-e" then 
			result = "EXIT"
		else 
			error = true
		end if
	else if parse.len == 2 then 
		p1 = parse[0]; p2 = parse[1]
		if p1 == "cd" then
			Current_Path = Core.cd(object, p2)
		else if p1 == "-s" then 
			Core.sudo(object, p2)
		else if p1 == "cat" then
			Core.cat(object, p2)
		else if p1 == "edit" then
			Core.edit_file(object, p2)
		else if p1 == "crack" then
			Utils.decrypt(object, p2)
		else if p1 == "dc" then
			Utils.cipher(p2)
		else if p1 == "rm" then 
			Core.rm(p2)
		else if p1 == "pw" then 
			Core.pw(object, p2)
		else if p1 == "kill" then 
			Core.kill(object, p2.val)
		else if p1 == "git" then 
			Core.git(object, p2)
		else if p1 == "--" then
			result = Core.Probe(p2)
		else if p1 == "-w" then
			result = Core.Probe(nslookup(p2))
		else if p1 == "mount" then
			if p2 == "-e" then Utils.transfer_tools(object, true)
			if p2 == "-a" then Utils.transfer_tools(object)
		else if p1 == "eel" then
			if p2 == "-l" then Eel.get
			if p2 == "-p" then Eel.plant(object)
			if p2 == "--" then Eel.capture(object)
		else 
			error = true
		end if
	else if parse.len == 3 then 
		p1 = parse[0]; p2 = parse[1]; p3 = parse[2]
		if p1 == "-s" then 
			Core.sudo(object, p2, p3)
		else if p1 == "chmod" then 
			Core.ch(object, false, p2, p3)
		else if p1 == "touch" then 
			Core.tch(object, p2, p3)
		else if p1 == "git" then 
			Core.git(object, p2, p3) 
		else if p1 == "scp" then
			Surf.ssp(object, p1, p2, p3)
		else 
			error = true
		end if
	else if parse.len == 4 then
		p1 = parse[0]; p2 = parse[1]; p3 = parse[2]; p4 = parse[3]
		 if p1 == "-s" then 
			Core.sudo(object, p2, p3, p4)
		else if p1 == "chmod" then 
			Core.ch(object, true, p3, p4)
		else if p1 == "scp" then
			Surf.ssp(object, p1, p2, p3)
		else 
			error = true
		end if
	else
		return print(error+" too many arguments")
	end if
	return result
end function
Core.cmd_list = function()
	return print(format_columns("[CMD] [arg1] [arg2] [DESCRIPTION]\n-h * * Display_a_list_of_commands\n-a * * Toggle_Anonymous_Mode\n-p * * Print_Global_Path\n-c * * Clear_The_Screen\ncd path * Change_Directory(global_path)\nls * * List_Directory_Contents(+permissions)\nps * * List_All_Processes\n-s */-s/-u */user Sudo_[launch/root/user+username]\niam * * I_Am\nkill PID * Kill_Process\nchmod perms path Change_File_Permissions\npw user * Change_User_PW(requires_root)\nsf * * Sniff_Local_Machine\nrouter ip * Scan_Router_Info\nlan * * Poor_Man_Scan_Lan\ngit -u/-- */package Update_Packages\n-- ip * target_ip_for_Net_Session_Entry\n-w domain * Target_Domain_Net_Session\nbf * * Brute_Force_Attacks(dict/Hail_Mary)\nwipe * * Wipe_Tools_From_Machine"))
end function
///======================= OBJECT POOL =========================////
Core.objects = function()
	objects = [globals.Shells, globals.Computers, globals.Files]
	if objects.len == 0 or objects[0].len == 0 or objects[1].len == 0 or objects[2].len == 0 then return print(warning+" no object options found")
	selected_obj = null
	selecting = true
	sm = 0 
	while selecting == true 
		if selecting == false then break
		c = 1 // count
		menu = [color.white+"~^~^~^~ <u>Main</u> ~^~^~^~"+color.cap, color.purple+"~^~^~^~ Shells ~^~^~^~"+color.cap, color.blue+"~^~^~^~ Computers ~^~^~^~"+color.cap, color.green+"~^~^~^~ Files ~^~^~^~"+color.cap, color.grey+"~^~^~^~ Other ~^~^~^~"+color.cap]
		
		if sm == 0 then 
			options = [color.purple+" Shells "+color.cap+"(<b>"+color.white+globals.Shells.len+color.cap+"</b>)", color.blue+" Computers "+color.cap+"(<b>"+color.white+globals.Computers.len+color.cap+"</b>)", color.green+" Files "+color.cap+"(<b>"+color.white+globals.Files.len+color.cap+"</b>)",]
		else 
			options = objects[sm-1]
		end if
		choices = menu[sm]
		for o in options
			info = ""
			if sm == 0 then
				info = info+o 
				in_main = true
			else if sm == 1 then 
				col = color.white
				u = Utils.user(o[0].shell)
				if @u == "root" then col = color.green
				if @u == "guest" then col = color.orange
				if @u == "unknown" then col = color.red
				i = o[0].pc.public_ip
				if globals.anonymous == true then i = "HIDDEN"
				info = "[ " +col+ u +color.cap+ " ]<s>   </s>{" +color.white+i+color.cap+":"+color.grey+o[0].pc.local_ip+color.cap+"}"
				in_main = false
			else if sm == 2 then		// computer exploit
				col = color.white
				u = Utils.user(o[0].PC)
				if @u == "root" then col = color.green
				if @u == "guest" then col = color.orange
				if @u == "unknown" then col = color.red
				i = o[0].PC.public_ip
				if globals.anonymous == true then i = "HIDDEN"
				info = " [ "+col+ u +color.cap+" ]<s>   </s>{" +color.white+i+color.cap+":"+color.grey+o[0].PC.local_ip+color.cap+"}"
				in_main = false
			else if sm == 3 then 
				lvl=""
				if o[0].F.has_permission("r") then lvl = lvl+"r"
				if o[0].F.has_permission("w") then lvl = lvl+"w"
				if o[0].F.has_permission("x") then lvl = lvl+"x"
				info = format_columns(o[0].F.name+" "+o[0].F.owner+" "+o[0].F.group+" "+lvl+" "+o[0].F.permissions)
				in_main = false
		end if
		// ;-;
			if sm == 0 then 
				choices = choices+"\n"+c+".)"+info
			else
				choices = choices+"\n"+c+".)"+info+" "+o[1]
			end if
			c = c+1
		end for
		
		if sm == 0 then 
			print(format_columns(choices))
		else 
			print(choices)
		end if
		choice_response = null
		if in_main == true or sm == 0  then 
			menu_response = user_input(color.green+"[ SELECT MENU ] "+color.cap+color.grey+"* exit to return*"+color.cap+color.white+" --> ")
			if menu_response == "exit" then 
				selecting = false
				return null
			end if
			sm = menu_response.val
		end if
		
		if sm == 0 and in_main == false then return
		if sm > 0 and in_main == false then 
			choice_response	= user_input(color.green+"[ CHOOSE OPTION ] "+color.cap+color.grey+"* Press 0 to return*"+color.cap+color.white+" --> ")
			if choice_response.val == 0 then 
				sm = 0
				continue
			end if 
			if choice_response.val > options.len then continue
			if choice_response.val == 0 then sm = 0

			attack_choice = user_input(color.orange+"[ CONFIRM ] \n"+color.white+"1.)"+color.cap+color.purple+" Surf Mode\n"+color.white+"2.)"+color.cap+color.red+" Remove Object\n"+color.white+"-- "+color.cap+color.grey+" * Press any to return *"+color.cap+color.white+" --> ")
			attack_choice = attack_choice.val
			if attack_choice == 1 then
				chosen_obj = options[choice_response.val-1] 
				selected_obj = chosen_obj[0]
				selecting = false
				return selected_obj
			else if attack_choice == 2 then 
				Core.remove(sm, choice_response)
			end if
		end if
	end while

end function

/////////////////// ADD 
Core.add = function(object) // : map
	if (object isa ShellObject) == true then 
		globals.Shells = globals.Shells.push([object, "captured"])
	else if (object isa CompObject) == true then 
		globals.Computers = globals.Computers.push([object, "captured"])
	else if (object isa FileObject) == true then 
		globals.Files = globals.Files.push([object, "captured"])
	else 
		return print(warning+" unable to add object to the pool: "+typeof(object))
	end if

end function
/////////////////// REMOVE 
Core.remove = function(type, index) // : number, : number
	t = "unknown"
	if type == 1 then 
		t = "shell"
		globals.Shells = globals.Shells.remove(index)
	else if type == 2 then
		t = "pc" 
		globals.Computers = globals.Computers.remove(index)
	else if type == 3 then 
		t = "file"
		globals.Files = globals.Files.remove(index)
	else 
		return print(warning+" unable to remove "+t+" object from the pool")
	end if
	
end function
/////////////////// REMOVE 
Core.list = function(type, index) // : number, : number
	t = "unknown"
	if type == 1 then 
		t = "Shells:"
		o = globals.Shells
	else if type == 2 then
		t = "Computers:" 
		o = globals.Computers
	else if type == 3 then 
		t = "Files:"
		o = globals.Files
	else if type == null then
		t = "Objects:"
		o = [globals.Shells, globals.Computers, globals.Files]
	end if
	print("<b><ul>"+t+"</b>          </ul>")
	count = 1
	for i in o 
		if sm == 0 then
			info = info+o 
			in_main = true
		else if sm == 1 then 
			c = color.white
			u = Utils.user(o.shell)
			if @u == "root" then c = color.green
			if @u == "guest" then c = color.orange
			if @u == "unknown" then c = color.red
			info = "[ " +c+ u +color.cap+ " ] "
			in_main = false
		else if selected_menu == 2 then		// computer exploit
			c = color.white
			u = Utils.user(o.PC)
			if @u == "root" then c = color.green
			if @u == "guest" then c = color.orange
			if @u == "unknown" then c = color.red
			info = "[ " +c+ u +color.cap+ " ]<s>   </s>{" +color.white+o.ip+color.cap+":"+color.grey+o.lan+color.cap+"}"
		else if sm == 3 then 
			lvl=""
			if o.F.has_permission("r") then lvl = lvl+"r"
			if o.F.has_permission("w") then lvl = lvl+"w"
			if o.F.has_permission("x") then lvl = lvl+"x"
			info = format_columns(o.F.name+" "+o.F.owner+" "+o.F.group+" "+lvl+" "+o.F.permissions)

		end if
		print(format_columns(count+".) "+info))
	end for
	
end function

// =======================  cd =======================

Core.cd = function(obj, p = home_dir)
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	dir = obj.File(p)
	if dir == null then return print("No directory found")
	globals.Current_Path = p
	return globals.Current_Path
end function
// =======================  ls =======================
Core.ls = function(obj)
	p = globals.Current_Path
	if not p then p = current_path
	print(init+" fs: "+color.yellow+p)
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then 
		folder = obj.host_computer.File(p)
	else if typeof(obj) == "computer" then 
		folder = obj.File(p)
	end if
	if folder == null then return print("ls no file or directory found")
	if not folder.has_permission("r") then return print("You do not have read access for "+folder)
	folder_path = p
	sub_files = folder.get_folders + folder.get_files
	output = ""
	for f in sub_files
		if output.len > 0 then 
			output = output + "\n"
		end if
		file_name = f.name
		permission = f.permissions
		output = output + permission + " " + f.owner + " " + f.group + " " + f.size + " 00:00 " + file_name
	end for
	print(format_columns(output))
end function
// =======================  cat =======================
Core.cat = function(obj, pathFile)
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	file = obj.File(pathFile)

	if file == null then return print("cat: file not found: "+pathFile)
	if file.is_binary then return print("cat: can't open " + file.path + ". Binary file")	
	if not file.has_permission("r") then return print("cat: permission denied")
	print(file.get_content)
end function

// =======================  touch =======================
Core.tch = function(obj, pathFile, fileName)
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	file = obj.touch(pathFile, fileName)
	if file == false then return print("touch: failed")
	print(fileName+" created at path "+ pathFile)
end function
// =======================  edit =======================
// this is really, really bad
Core.edit_file = function(obj, pathFile)
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	if typeof(obj) == "computer" then obj = obj.File(pathFile)
	if typeof(obj) == "file" then 
		f = obj
	else 
		f = obj.File(pathFile)
	end if

	if f == null then
		return print("no file found")
	else if f.has_permission("r") == false or f.has_permission("w") == false then 
		return print("edit: error with file")
	end if
	if f.is_binary then return print("cat error: binary file")
	content = f.get_content
	lines = content.split("\n")
	c = 0
	con = null
	info = color.yellow+f.name
	print(info)
	for l in lines 
		print("( "+color.white+ c +color.cap+ " ) : "+l)
		c = c +1
	end for
	tail = ""
	content = null
	input = user_input("select line: ").to_int
	replace = user_input("enter content: ")
	for l in lines
		if l == char(10) or l == "" then 
			content = content+l 
		else
			content = content + char(10) + l
		end if
	end for
	if lines.len-1 < input then
		print("c1")
		//lines = lines.split(char(10))
		print(lines.len)
		for i in range(lines.len-1, lines.len+input)
			if lines.len+input == input then 
				content = content+replace
			else 
				content = content + ""+char(10)
			end if
		end for
	else 
		lines[input-1] = replace
	end if
	r = f.set_content(content)
	if r == 1 then print(color.white+f.name+color.green+" edit --> OK")
end function
// =======================  rm =======================
Core.rm = function(obj, pathFile)
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	file = obj.File(pathFile)
	if file == null then return print("rm: cant find file")
	if file.has_permission("w") == false then return print("rm: cant write to file")
	del = file.delete
	wait(0.1)
	if del.len < 1 then print("deleted "+file.name)
	print(fileName+" created at path "+ pathFile)
end function

// =======================  iam =======================
Core.me = function(obj)
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then me = obj.host_computer.File(home_dir).owner
	if typeof(obj) == "computer" then me = obj.File(home_dir).owner
	if typeof(obj) == "file" then me = obj(home_dir).owner
	return me
end function
// =======================  pw =======================
Core.pw = function(obj, user)
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	inputMsg = "Changing password for user " + user +".\nNew password:"
	inputPass = user_input(inputMsg, true)
	output = obj.change_password(user, inputPass)
	if output == true then return print(user+" password modified OK")
	if output then return print(output)
	print(warning+" password not modified, are you root?")
end function
// =======================  ps =======================
Core.ps = function(obj)
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	output = obj.show_procs
	return print(format_columns(output))
end function
// =======================  kill =======================
Core.kill = function(obj, pid)
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	if typeof(pid) != "number" then return print(warning+" The PID must be a number\n")
	output = obj.close_program(pid)
	if output == true then return print("Process " + pid + " closed");
	if output then return print(output)
	print("Process " + pid + " not found")
end function
// =======================  sudo =======================
Core.sudo = function(s = get_shell, arg, arg2=null, arg3=null)
	o = s
	if typeof(s) == "map" then s = Utils.handle(s)
	computer = s.host_computer
	inputPass = user_input("Password: ", true)
	if arg == "-u" then s = get_shell(arg2, inputPass)
	if arg == "-s" or arg == "-l" then s = get_shell("root", inputPass)
	if not s then return print(color.orange+"AUTH FAIL")
	if arg == "-l" then 
		program = computer.File(arg2)
		if not program then return print(arg2 + " not found.")
		if not arg3 then s.launch(arg2)
		if arg3	then s.launch(arg2, arg3)
	end if
	confirm = user_input("[SELECT] \n"+color.white+"1.) Terminal\n"+color.grey+"2.) Pass Shell"+color.cap+"\n3.) Surf Mode"+"\n--> ")
	if confirm.val == 1 then return s.start_terminal
	if confirm.val == 2 then return s
	if confirm.val == 3 then return Main.surf_mode(o)
end function
// =======================  chmod =======================
Core.ch = function(obj, recursive, perms, path_to_file)
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	file = obj.File(path_to_file)
	if file == null then return print("cannot find file "+path_to_file)
	output = file.chmod(perms, recursive)
	if output then print(output)
end function
// =======================  ping =======================
Core.p = function(shell, ip)
	result = shell.ping(ip)
	if result then
    	if typeof(result) == "string" then
        	print(result) 
		else
	    	print("Ping successful")
		end if
	else
		print("ip unreachable");
	end if
end function

// ======================= SERVICES =========================
// ======================= SCP =========================
Core.ssp = function(remote_shell, type, origPath, destPath=null)
	if type == "-u" then 
		remote_shell.scp(origPath, global_path, home_shell)
	else if type == "-d" then 
		home_shell.scp(origPath, destPath, remote_shell)
	else 
		return print("an error occured")
	end if

end function 
// ======================= SSH =========================
Core.ssh = function(shell, connect_string, ip, port = 22)
	object = Utils.handle(object)
	if typeof(object) != "shell" then return print(" no shell detected")
	connect_string = connect_string.split("@")
	service = object.connect_service(ip, port, connect_string[0], connect_string[1])
	return service
end function
// ======================= FTP =========================
Core.ftp = function(object, connect_string, ip, port = 21)
	object = Utils.handle(object)
	if typeof(object) != "shell" or typeof(obj) == "ftpshell" then return print(" no shell detected")
	if not object then object = Global_Shells[0][0]
	connect_string = connect_string.split("@")
	service = object.connect_service(ip, port, connect_string[0], connect_string[1], "ftp")
	return service
end function
// ======================= sniff =========================
Core.sniff = function()
	print(init+" Listening for connections . . .")
	metaxploit = include_lib("/lib/cheese/metaxploit.so")
	if not metaxploit then metaxploit = include_lib("/lib/metaxploit.so")
	if not metaxploit then metaxploit = include_lib("/lhome/guest/metaxploit.so")
	if not metaxploit then return print("no mx found")
	output = metaxploit.sniffer
	print(output)
end function
// ======================= router ========================= 
Core.router = function(p1)
	router = get_router( p1 )
	if router == null then 
		print("scanrouter: ip address not found")
		return
	end if
	print("Connecting to router at address: " + p1 + "\nScanning kernel library...")
	version = router.kernel_version
	if not version then
		print("Warning: kernel_router.so not found")
	else 
		print("kernel_router.so : v" + version)
	end if
	
	firewall_rules = router.firewall_rules
	if typeof(firewall_rules) == "string" then exit(firewall_rules)
	print("\nScanning firewall rules...")
	if firewall_rules.len == 0 then exit("No rules found.")
	info = "ACTION PORT SOURCE_IP DESTINATION_IP"
	for rules in firewall_rules
		info = info + "\n" + rules
	end for
	print(format_columns(info) + "\n")
end function


// ======================= lan =========================
Core.lan = function(dump)
	c = get_shell.host_computer
	if c.is_network_active == false then return print("Computer is operating on 0.0.0.0")
	r = get_router
	devices = r.devices_lan_ip
	deviceList = []
	//print("\n")
	for device in devices
		lanDevice = get_router(device)
		if lanDevice then
			if deviceList.indexOf(lanDevice.local_ip) == null then deviceList.push(lanDevice.local_ip)
		end if
	end for
	r = get_router
	devices = r.devices_lan_ip
	for device in devices
		ports = null
		is_switch = get_switch(device)
		if get_switch(device) == null then
			deviceInfo = "<color=green>* router *</color>"// type: "+typeof(is_switch)
		else
			deviceInfo = "<color=yellow>| switch |</color>"// type: "+typeof(is_switch)
	end if
	lanDevice = get_router(device)
	if lanDevice then
		if device == c.local_ip then device = "<color=green>" + device + "</color>"
		firewall_rules = lanDevice.firewall_rules
		if firewall_rules and firewall_rules.len > 0 then firewall = color.orange+"(firewall)" else firewall = ""
		print(color.blue+"~^~^~^~^~^~^~^~^~^~"+color.cap+"<b>[<color=white>" + device + "</color>]</b> " + deviceInfo + " " + firewall)
		for subDevice in lanDevice.devices_lan_ip
			if deviceList.indexOf(subDevice) == null then
				ports = lanDevice.device_ports(subDevice)
				if not ports then continue
				if ports.len > 0 then
					if subDevice == c.local_ip then subDevice = "<color=green>" + subDevice + "</color>"
					print("<b>   [" + subDevice + "]")
					portPrint = ""
					for port in ports
						if lanDevice.port_info(port) != null then info = lanDevice.port_info(port).split(" ")[0] else info = null
						if info != null then
							if port.is_closed then
								port_status = color.orange
							else
								port_status = color.green
							end if
							portPrint = portPrint + format_columns(port_status + " " + port.port_number + " " + info +color.cap+"\n")
						end if
					end for
					if portPrint != "<i>~^~^~~[" then print(portPrint)
				end if
			end if
		end for
	end if
end for
end function



// =======================  apt-get =======================
PendingUpdating = function(folderPath)
	aptclient = include_lib("/lib/aptclient.so")
	if not aptclient then
    	aptclient = include_lib(current_path + "/aptclient.so")
	end if
	pendingUpdate = []
	targetFolder = get_shell.host_computer.File(folderPath)
	if targetFolder != null then
		files = targetFolder.get_files
		for itemFile in files
			output = aptclient.check_upgrade(itemFile.path)
			if output == true then
				print(itemFile.name+" was found and needs an update")
				pendingUpdate.push(itemFile.name)
			end if
		end for
	end if
	return pendingUpdate
end function 

//  shell: Shell
// (action) p1: action: string
// (lib) p2: string | null
// (force) p3: boolean | null

// i dont even want to look at this pos 
// =======================  apt-get =======================
Core.git = function(shell, cmd, param=null)
	shell = Utils.handle(shell)
	aptclient = include_lib("/lib/aptclient.so")
	if not aptclient then
    	aptclient = include_lib(current_path + "/aptclient.so")
	end if
	if not aptclient then return print(warning+ " Missing aptclient.so library in the /lib path or the current folder")
	if cmd == "-u" then // update
		print("Updating package lists...")
		output = aptclient.update
		if output then print(output)
	else if cmd == "--" then // upgrade
		pendingPackages = PendingUpdating("/lib") + PendingUpdating("/bin")
		if pendingPackages.len == 0 then return print("c1: No updates needed")
		print("The following packages will be updated:")
		pkgs = ""
		for itemPackage in pendingPackages
			pkgs = pkgs + " " + itemPackage
		end for
		print(pkgs)
		force = null
		if param != "-f" then 
			option = user_input("\nDo you want to continue?(y/n): ")
			if option != "y" or option != "yes" then return print("Exiting . . .")
		end if
		counter = 0
		for itemPackage in pendingPackages
			output = aptclient.install(itemPackage)
			if output == true then
				counter = counter + 1
			else if output then
				print(output)
			end if
		end for
	print(counter + " packages updated")
	
	else if param then 
		if cmd == "install" then 
			print("Downloading " + param)
			output = aptclient.install(param)
			if output == true then 
				print(param + " installed")
			end if
			print(output)
		else if cmd == "search" then 
			print(aptclient.search(p2));
		else if cmd == "show" then		
			print(aptclient.show(p2));
		else if cmd == "addrepo" then
			port = 1542
			output = aptclient.add_repo(param)
			if output then print(output)
			print("Repository " + param + " added succesfully.\nLaunch apt with the update option to apply the changes")
		else if cmd == "delrepo" then
			output = aptclient.del_repo(param)
    		if output then print(output)
    		print("Repository " + param + " removed succesfully.\nLaunch apt with the update option to apply the changes")
		
		end if
	end if
	     
end function

//////////////////////////////////////////////////////////////////////////////  
///============================ ATTACKS / FUNCTIONS =====================///
//////////////////////////////////////////////////////////////////////////
///============================ PROBE =====================///
Core.Probe = function(addr)
    print(init+"Net Session: searching: "+addr)
    router = null;ports = null;isLanIp = is_lan_ip(addr);fwd_machines = [];closed_machines = [];
    if isLanIp then 
		print("lan detected")
        router = get_router;
		if not router then exit(error+" An error occured")
		ports = router.device_ports(addr) // these appear to be forwarded ports ?
	else 
        router = get_router(addr); 
		if not router then exit(error+" An error occured")
		ports = router.used_ports
	end if
 	devices = router.devices_lan_ip 	// any machine on the network reachable by ping on this address 
    //optional router attack
    if not ports or ports.len == 0 then 
        input = user_input(title+color.orange+"[Alert] No forward ports found\n"+color.yellow+"[SELECT]\n1.) Exploit the router \n0.) Exit\n--> ")
        if input.val == 1 then return Core.RouterEntry(addr, devices)
        if input.val != 1 then return print(title+" exiting . . .")
    end if 

    local_machines = devices // assign this list to a refernce of machine if we have 
    print(color.blue+"><> ><>"+color.cap+color.grey+" Machines reachable by ping: "+color.cap+"[ <b>"+color.white+devices.len+color.cap+"</B> ]"+color.blue+" ><> ")
    print(color.blue+color.fill); print(color.blue+"><> ><>"+color.cap+color.grey+" Machines with fowarded ports"+color.cap+color.blue+" ><> ><>")
    choices = color.orange+"0.) Attack_Router"; num = 1;info = null;
    for port in ports
        service = router.port_info(port)
		if not service then continue
        service_parsed = service.split(" ")
        service_lib = service_parsed[0]
        service_version = service_parsed[1]
        status = color.green+"open"+color.cap
        lan = port.get_lan_ip
        number = port.port_number
        if (port.is_closed and not isLanIp) then 
            status = color.red+"closed"+color.cap
            closed_machines.push(lan)
        else  
            // insert into list of processes to exploit
            fwd_machines.push([lan, number])
            choices = choices + "\n"+color.cyan + num+".) "+color.cap+color.purple+ lan +color.cap+color.white+ " " + number +color.cap+color.green +" " + service_lib
            num = num+1	
        end if
        info = info + color.cyan+service_lib+color.cap + " " + status + " " +color.grey+service_version+color.cap + " " + color.purple+lan+color.cap+color.white+" "+number+"\n"
    end for
    if fwd_machines.len == 0 then 
        input = user_input(title+color.orange+"[Alert] No open ports found\n"+color.yellow+"[SELECT]\n1.) Exploit the router \n0.) Exit\n--> ")
        if input.val == 1 then return Core.RouterEntry(addr)
		if input.val != 1 then return print(title+" exiting . . .")
    end if 
    print(color.blue+"><>"+color.cap+" "+addr+color.cap+"::"+color.grey+number+color.cap)
    print(color.green+"><> "+color.cap+format_columns("LIB STATE VERSION LAN PORT")+color.green+" ><>")
    print(format_columns(info))
    print(color.blue+color.fill); print(format_columns(choices)); print(color.blue+color.fill)
    response = user_input(title+color.green+"-- "+color.white+"Select Entry"+color.cap+color.grey+" * Enter to Return *"+color.cap+color.green+" --> "+color.cap+color.white)
    if response.len == 0 then return
	response = response.val
    if response == 0 then return Core.RouterEntry(addr, devices)
	lan = fwd_machines[response - 1][0]
	port = fwd_machines[response - 1][1]
	return Core.NetEntry(addr, lan, port)
end function
///============================ ROUTER ENTRY =====================///
Core.RouterEntry = function(addr, devices)
    // begin a task to begin a net session hack
	hacked_object = null
	print(init+" Beginning Router Entry @ "+addr)
	if devices.len == 0 then return print(warning+" no devices found")
	options = "[ Computers ]"; count = 1; 
	for device in devices 
		options = options+"\n"+count+".) "+color.white+device
		count = count+1
	end for
	options = options + "\n0.)"+color.purple+" Net Router Entry\n|| Return to Main\n"+color.green+"[Select] --> "+color.cap
	choice = user_input(options)
	if choice == "||" then return print("Returning . . .")
	choice = choice.val
	if choice == 0 then 
		hacked_object = auto_hack(addr, 0)
	else 
		hack_object = auto_hack(addr, 0, devices[choice-1])
	end if
	return hacked_object
end function
///============================ NET ENTRY =====================///
Core.NetEntry = function(ip, lan, port)
	print(init+color.white+" Beginning Net Entry!"+color.cap+" --> "+color.grey+ip+color.cap+"/"+color.purple+lan+color.cap+":"+color.blue+port)
	hacked_object = null
	//obj = Utils.handle(object)
	if not is_valid_ip(ip) then return print(warning+ "invalid IP")
	hacked_object = auto_hack(ip, port)
	if not hacked_object then 
		print(warning+" "+color.white+ip +color.cap+" @ "+color.grey+lan+color.cap+" : "+color.orange+port+color.red+" Net Session FAILED" )
        input = user_input("1.) Router Attack\n2.) New Net Attack \n3.) Bounce Test \n4.) Exit\nSELECT ->  ")
        input = input.val
		if input == 1 then
            hacked_object = auto_hack(ip, 0)
            if not hacked_object then return print(warning+ip+" couldnt be penetrated via router")
		end if
		if input == 2 then return Core.Probe(ip)
		if input == 3 then 
			value = user_input(color.yellow+"Enter a LAN: \n-->") 
        	hacked_object = auto_hack(addr, 0, value)
		end if
		if input == 4 then exit("You chose to exit")
	end if
	print("exiting net entry . . .")
	return hacked_object
end function
///============================ LOCAL ELEVATION wip =====================///
Core.LocalElevation = function(object)
	obj = Utils.handle(object)
	if typeof(obj) == "shell" then file = obj.host_computer.File("/home/guest/autolocal")
	if typeof(obj) == "computer" then file = obj.File("/home/guest/autolocal")
	if typeof(obj) == "file" then file = obj("/home/guest/autolocal")
	attempt = obj.launch("/home/guest/autolocal")	
	// returns null on success, 0 on failure
	return attempt
end function




///============================ BRUTE =====================///
Core.brute_v2 = function(object, type = 0)
	choice_arr = ["/home/2NA/src/dict/dictionary.txt", ]
	choice_sel = choice_arr[type]
	
	object = Utils.handle(object)
	if typeof(object) == "shell" then object = object.host_computer 
	dict = null
	dict = object.File(choice_sel)
	if dict == null then 
		p = user_input("no path found, specify it here\n--> ")
		dict = object.File(p)
		if dict == null then return print("Path incorrect; Not saying its a you thing, but . . . ")
	end if
 	pass_list = dict.get_content.split("\n")
	tries = 1
	for pass in pass_list
		print("[tsunamiV2] attempting login with pw: "+pass+ " #"+tries);
		result = get_shell("root", pass)
		if result != null then
			print(pass) 
			return Utils.got_rooted()
		end if
		tries = tries +1;wait(0.1)
	end for
	dict = null 
end function



//////////////////////////////////////////////////////////////  
///======================= EEL ===========================///
////////////////////////////////////////////////////////////

Eel = {}

Eel.get = function()
	print(title+"Listening for upcoming connections...")
	metaxploit = meta
	shells = []
	while shells.len == 0	
		shells = metaxploit.rshell_server
		if(typeof(shells) == "string") then exit(shells)	
		if(shells.len == 0) then wait(2)
	end while

	option = 0
	while typeof(option) != "number" or (option < 1 or option > shells.len)
		print(shells.len + " shell(s) connected!\n<b>Select a shell to start a terminal:</b>")
		for i in range(0, shells.len - 1)
			print("\n<b>"+color.purple+"Shell"+color.cap+" [ " +color.white+ (i + 1) +color.cap+ " ]</b>\n"+color.white+"Public IP: " +color.cap+ shells[i].host_computer.public_ip + "\n"+color.grey+"Local IP: " +color.cap+ shells[i].host_computer.local_ip)
		end for
		print("-----------")
		option = user_input("Select shell>").to_int
	end while

	choice = user_input("Select Choice>\n"+color.white+"1.)"+color.cap+color.green+" Surf Mode\n"+color.white+"2.)"+color.yellow+" Terminal"+color.cap+" [this will leave a "+color.orange+"trace"+color.white+"]\n--> ").to_int
	if choice == 1 then 
		so = new ShellObject 
		so.init(shells[option-1])
		print("Surfing on shell # " +color.green+ option)
		Main.surf_mode(so)
	else if choice == 2 then 
		print("Starting terminal on shell # " +color.green+ option)
		shells[option - 1].start_terminal
	end if

end function

Eel.capture = function()
	confirm = user_input("*"+color.white+" Press 1 to extend eel"+color.cap+" * "+color.grey+"Press Any to Return"+color.cap+" * -->").to_int
	if confirm != 1 then return
	metaxploit = meta
	shells = []
	while shells.len == 0	
		shells = metaxploit.rshell_server
		if(typeof(shells) == "string") then exit(shells)	
		if(shells.len == 0) then wait(2)
	end while
	option = 0
	while typeof(option) != "number" or (option < 1 or option > shells.len)
		print("<b>"+color.purple+shells.len + " shell(s) connected!")
		for i in range(0, shells.len - 1)
			
			print("\n<b>"+color.yellow+"Capturing Shell"+color.cap+" [ " +color.white+ (i + 1) +color.cap+ " ]</b> "+color.purple+"Public IP: " +color.cap+ shells[i].host_computer.public_ip + color.white+"Local IP: " +color.cap+ shells[i].host_computer.local_ip)
			transfer = Utils.transfer_tools(shells[i])
			if not transfer then print(color.orange + "eel transfer --> FAILED")
			if transfer == true then capture = shells[i].launch("/home/guest/eel", "auth")
			if transfer == true and capture != 0 then print(color.green+"eel --> LAUNCHED")
		end for
		print("-----------")
		option = user_input("Select shell>").to_int
	end while
	
end function

Eel.collect_info = function()
	metaxploit = meta
	shells = []
	while shells.len == 0	
		shells = metaxploit.rshell_server
		if(typeof(shells) == "string") then exit(shells)	
		if(shells.len == 0) then wait(2)
	end while
	option = 0
	while typeof(option) != "number" or (option < 1 or option > shells.len)
		print(shells.len + " shell(s) connected!\n<b>Select a shell to start a terminal:</b>")
		for i in range(0, shells.len - 1)
			
			print("\n<b>"+color.yellow+"Phishing Shell"+color.cap+" [ " +color.white+ (i + 1) +color.cap+ " ]</b> "+color.purple+"Public IP: " +color.cap+ shells[i].host_computer.public_ip + color.white+"Local IP: " +color.cap+ shells[i].host_computer.local_ip)
			remote_transfer(shells[i])
			if not transfer then print(color.orange + "eel transfer --> FAILED")
			if transfer == true then capture = shells[i].launch("/home/guest/eel", "auth")
			if transfer == true and capture != 0 then print(color.green+"eel --> LAUNCHED")
		end for
	end while
	
end function

Eel.plant = function(object)
	object = Utils.handle(object)
	eel = object.host_computer.File("/home/guest/eel")
	if eel == null then eel = Utils.transfer_tools(object, true)
	wait(0.1)
	l = 0
	if eel == true then l = object.launch("/home/guest/eel", "auth")
	if l == 0 then print(warning+" failed to launch eel")
end function



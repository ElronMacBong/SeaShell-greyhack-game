if not globals.entry_core then exit("><> ><> ><>")
//////////////////////////////////////////////////////////////  
///======================= CORE =========================////
////////////////////////////////////////////////////////////
Core = {}
CMD = {}
///======================= CMD isValid =========================////
Core.isValid = function(param)
	pos = 0
	for p in Core.list
		pos = pos+1
		if p["name"] == param then return p
		if p["name"] == "--" and (is_valid_ip(param) or is_valid_ip(nslookup(param))) then 
			if globals.debug then print(color.green+"FOUND COMMAND: "+ p["name"])
			return p
		end if
	end for
	return null
end function
// format command
fcmd = function(string)
	if string.indexOf("|") == null then return print("not a parsable command") 
	rep = string.replace("|", " ")
	parse = rep.split(" ")
	return parse
end function
///======================= CMD hasRequiredArgs =========================////
Core.hasRequiredArgs = function(cmd, p)
	if globals.debug then print(color.red+"CMD: "+cmd["name"])
	if globals.debug then print(color.yellow+"REQUIRED: "+cmd["params"].len)
	if globals.debug then print(color.orange+"PASSED ARGS: "+color.cap+color.grey+p)
	passed = 0
	for cmdIndex in cmd["params"]
		if cmdIndex == "*" then
			if globals.debug then print("args: c1") 
			passed = passed+1
			continue
		end if
		if globals.debug then print(color.purple+"POSSIBLE ARG: "+cmdIndex)
		if cmdIndex.indexOf("|") then
			if globals.debug then print("args: c2")
			parse = fcmd(cmdIndex)
			if globals.debug then print(parse)
			for parsed in parse
				//if globals.debug then print("parsed: "+parsed)
				//if globals.debug then print("p.indexOf(parsed): "+p.indexOf(parsed)+" TYPE: "+typeof(p.indexOf(parsed)))
				//if globals.debug then print("cmdIndex == * "+(parsed == "*"))
				if typeof(p.indexOf(parsed)) == "number" or (parsed == "*") then 
					passed = passed+1
					break
				end if
			end for
		else 
			if globals.debug then print("args: c3")
			for argIndex in p
				//if globals.debug then print(color.white+"argIndex: "+argIndex)
				//if globals.debug then print("cmdIndex.indexOf(argIndex): "+cmdIndex.indexOf(argIndex)+" TYPE: "+typeof(cmdIndex.indexOf(argIndex)))
				//if globals.debug then print("cmdIndex == * "+(cmdIndex == "*"))
				if typeof(p.indexOf(argIndex)) == "number" or (cmdIndex == "*") then 
					passed = passed+1
				end if
			end for
		end if
		
	end for
	if globals.debug then print("total: "+passed)
	if passed == cmd["params"].len then return true
	if globals.debug then print("c6")
	return null
end function
///======================= CMD =========================////
Core["cmd"] = function(object, params)
	error = null
	result = null
	cmd = params.split(" ")
	if globals.debug then print(color.white+"recieved cmd: <b>"+color.cap+color.grey+cmd)
	valid = Core.isValid(cmd[0])
	if not valid then return print(warning+color.yellow+"Invalid Command\n"+color.white+"Use command "+color.grey+"<b>-h</b>"+color.cap+color.white+" for list of valid commands")
	if globals.debug then print(color.green+"running CMD: <b>"+color.cap+color.white+valid["name"])
	run = valid["run"]
	if cmd.len == 1 then
		if globals.debug then print("cmd: c1")
		if valid["cb"] == "result" then
			if globals.debug then print("cmd: c1a")  
			if valid["name"] == "-g" then result = run
			if not valid["name"] == "-g" then result = run(object, cmd[0])
		else if valid["cb"] == "custom" then
			data.anon = globals.anonymous
			//data.so = @ShellObject;data.co = @CompObject;data.fo = @FileObject;data.DB1 = globals.DB1;data.DB2 = globals.DB2;
			data.root = null;
			run(object, "-p")
			if data.root != null then result = data.root
		else if valid["cb"] == "Current_Path" then  
			Current_Path = run(object)
		else if valid["cb"] == "anon" then  
			anonymous == run
		else if valid["cb"] == "general" then 
			run
		else if valid["cb"] == "EXIT" then
			result = "EXIT" 
		else
			run(object)
		end if
	else if cmd.len > 1 then
		cmd.pull // remove the main param, and leave arguments
		if valid["params"].len < cmd.len then return print(warning+ "too many arguments")
		if globals.debug then print("cmd: c2") 
		args = Core.hasRequiredArgs(valid, cmd) 
		if args == null then return print("lacking required args c2")
		run = valid["run"]
		if cmd.len == 1 then
			if valid["cb"] == "result" then
				if globals.debug then print("cmd: c2a")
				result = run(object, cmd[0])
			else if valid["cb"] == "general" then
				run(cmd[0])
			else
				run(object, cmd[0])
			end if
		else if cmd.len == 2 then 
			// etc etc
			if valid["cb"] == "result" then
				result = run(object, cmd[0], cmd[1])
			else if valid["cb"] == "general" then
				run(cmd[0], cmd[1])
			else if valid["cb"] == "custom" then
				//data.so = @ShellObject;data.co = @CompObject;data.fo = @FileObject;data.DB1 = globals.DB1;data.DB2 = globals.DB2;
				data.root = null
				run(object, cmd[0], cmd[1])
				if data.root != null then result = data.root
			else
				run(object, cmd[0], cmd[1])
			end if
		else if cmd.len == 3 then
			// etc etc 
			if valid["cb"] == "general" then
			else
				// moments like this, i miss the spread operator 
				run(object, cmd[0], cmd[1], cmd[2])
			end if
		end if
	end if
	return result
end function
///============================
// object: ShellObject: Map | CompObject: Map | FileObject: Map
// global_path = out global path fool
///======================= PROMPT =========================////
Core.prompt = function(o, p, anonymous)
	user_color = color.white
	type = color.purple+"S"+color.cap 
	if (o isa ShellObject) == true then
		if typeof(o.shell) == "ftpshell" then type = color.yellow+"FTP"+color.cap
		o = o.shell.host_computer
	else if (o isa CompObject) == true then
		o = o.PC 
		type = color.blue+"C"+color.cap
	else if (o isa FileObject) == true then 
		type = color.green+"F"+color.cap
	else 
		return print(warning+ " Invalid prompt type")
	end if
	user = Utils.user(o)
	if user == "root" or user == "2NA" then user_color = color.green
	if user == "guest" then user_color = color.orange
	if user == "unknown" then user_color = color.red
	ip = null; lan = null;
	if (o isa FileObject) == false then 
		ip = o.public_ip;lan = o.local_ip
	end if
	if anonymous == true then ip = "HIDDEN"
	if anonymous == true then lan = "HIDDEN"
		spacing = 3.9
	pc = "fish"
	spacing = spacing+(user.len+pc.len)*0.6
	str =  "\n<pos=04>—{<b>"+user_color+user+color.cap+"</b>}—[<b>"+type+"</b>]—{"+color.white + ip + color.cap+":"+color.grey + lan + color.cap+"}—[<b>"+color.white+p+color.cap+"</b>]<voffset=-0.5em><space=-"+spacing+"em><pos=00>|<voffset=-1em><space=-0.6em>|<voffset=-1.5em><pos=04>——:~"+color.white+"$"+color.cap+" " 				
	response = user_input(str)
	return response
end function
///============================
///======================= CMD  LIST =========================////
Core["cmd_list"] = function(usage = null)
	p = null
	if not usage then
		tData = []
		tData.push({"<b><u>[ NAME ]": [0,0,0,0]})
		tData.push({"[ ARGS ]": [12,0,0,0]})
		tData.push({"[ DESC ]          /\n": [55,0,0,0]})
		for c in Core.list
			tData.push({color.white+c["name"]+color.cap: [1,0,0,0]})
			tData.push({c["params"]: [10,0,0,0]})
			tData.push({color.grey+c["desc"]+"\n": [45,0,0,0]})
		end for
		print GFX.f(tData)
		p = true
	else
		locals.i = null
		for item in Core.list
			if item["name"] == usage then 
				locals.i = item
				break
			end if
		end for
		if not locals.i or not locals.i["usage"] then return print(color.grey+"*<i>Usage not found</i>*"+color.cap+" cmd:<b> "+color.white+usage+color.cap)//+"</b> \n-->"+color.grey+"* Chec")
		print(color.purple+"CMD: "+color.cap+"<b>"+usage+"</b>\n"+color.green+"ARGS: "+color.cap+locals.i["params"]+"\n"+color.white+"USAGE:"+color.cap+"\n"+locals.i["usage"])
	end if
	print(color.white+"<b>-->"+color.cap+ " *</b><i>"+color.grey+" Represents a dynamic, or optional parameter.")
	if p then print("*"+color.grey+"<i>DETAILS</i>"+color.cap+"*  Use cmd: "+color.white+"<b>-h [cmd_name]</b>"+color.cap+" for CMD usage")
end function
///============================
///======================= ANON MODE =========================////
Core["anon"] = function()
	g = true
	if globals.anonymous == 1 then g = false
	globals.anonymous = g
	return globals.anonymous
end function
///============================
///======================= OBJECT POOL =========================////
Core["objects"] = function(_, p = null)
	objects = [globals.Shells, globals.Computers, globals.Files]
	if objects.len == 0 or objects[0].len == 0 or objects[1].len == 0 or objects[2].len == 0 then return print(warning+" no object options found")
	selected_obj = null
	selecting = true
	sm = 0
	if p  == "-c" then 
		globals.Shells = [ [base_shell, "MAIN"] ] // our collection of global shell objects
		globals.Computers = [ [base_pc, "MAIN"] ] // our collection of global computer objects
		globals.Files = [ [base_file, "MAIN"] ] // our collection of global file objects
		return
	end if
	while selecting == true 
		if selecting == false then break
		c = 1 // count			
		addon = ""
		menu = [color.white+"~^~^~^~ <u>Main</u> ~^~^~^~"+color.cap, color.purple+"~^~^~^~ Shells ~^~^~^~"+color.cap, color.blue+"~^~^~^~ Computers ~^~^~^~"+color.cap, color.green+"~^~^~^~ Files ~^~^~^~"+color.cap, color.grey+"~^~^~^~ Other ~^~^~^~"+color.cap]
		if sm == 0 then 
			options = [color.purple+" Shells "+color.cap+"(<b>"+color.white+globals.Shells.len+color.cap+"</b>)", color.blue+" Computers "+color.cap+"(<b>"+color.white+globals.Computers.len+color.cap+"</b>)", color.green+" Files "+color.cap+"(<b>"+color.white+globals.Files.len+color.cap+"</b>)",]
		else 
			options = objects[sm-1]
		end if
		choices = menu[sm]
		for o in options
			info = ""
			if sm == 0 then
				info = info+o 
				in_main = true
			else if sm == 1 then 
				col = color.white
				u = Utils.user(o[0].shell)
				if @u == "root" then col = color.green;if @u == "guest" then col = color.orange;if @u == "unknown" then col = color.red;
				if globals.anonymous == false then addon = "\n"+color.white+"Bank: "+color.cap+o[0].bank+"\n"+color.white+"Mail: "+color.cap+o[0].email+"\n"+color.white+"Hash: "+color.cap+o[0].pass
				risk_color = color.white;if o[0].risk == 1 then risk_color = color.yellow;;if o[0].risk == 2 then risk_color = color.orange;if o[0].risk == 3 then risk_color = color.red;;if globals.anonymous == false then addon = "\n"+color.white+"Bank: "+color.cap+o[0].bank+"\n"+color.white+"Mail: "+color.cap+o[0].email+"\n"+color.white+"Hash: "+color.cap+o[0].pass
				i = o[0].pc.public_ip
				l = o[0].pc.local_ip
				if globals.anonymous == true then 
					i = "x.x.x.x"
					l = "x.x.x.x"
				end if
				info = "[ " +col+ u +color.cap+ " ]<s>   </s>{" +color.white+i+color.cap+":"+color.grey+l+color.cap+"}{"+risk_color+o[0].risk+color.cap+"}"+addon
				in_main = false
			else if sm == 2 then		// computer exploit
				col = color.white
				u = Utils.user(o[0].PC)
				if @u == "root" then col = color.green;if @u == "guest" then col = color.orange;if @u == "unknown" then col = color.red;
				if globals.anonymous == false then addon = "\n"+color.white+"Bank: "+color.cap+o[0].bank+"\n"+color.white+"Mail: "+color.cap+o[0].email+"\n"+color.white+"Hash: "+color.cap+o[0].pass
				risk_color = color.white;if o[0].risk == 1 then risk_color = color.yellow;if o[0].risk == 2 then risk_color = color.orange;if o[0].risk == 3 then risk_color = color.red;;if globals.anonymous == false then addon = "\n"+color.white+"Bank: "+color.cap+o[0].bank+"\n"+color.white+"Mail: "+color.cap+o[0].email+"\n"+color.white+"Hash: "+color.cap+o[0].pass

				i = o[0].PC.public_ip
				if globals.anonymous == true then i = "HIDDEN"
				info = " [ "+col+ u +color.cap+" ]<s>   </s>{" +color.white+i+color.cap+":"+color.grey+o[0].PC.local_ip+color.cap+"}{"+risk_color+o[0].risk+color.cap+"}"+addon
				in_main = false
			else if sm == 3 then 
				lvl=""
				if o[0].F.has_permission("r") then lvl = lvl+"r";if o[0].F.has_permission("w") then lvl = lvl+"w";if o[0].F.has_permission("x") then lvl = lvl+"x"
				info = format_columns(o[0].F.name+" "+o[0].F.owner+" "+o[0].F.group+" "+lvl+" "+o[0].F.permissions)
				in_main = false
		end if
		// ;-;
			if sm == 0 then 
				choices = choices+"\n"+c+".)"+info
			else
				choices = choices+"\n"+c+".)"+info+" "+o[1]
			end if
			c = c+1
		end for
		
		if sm == 0 then 
			print(format_columns(choices))
		else 
			print(choices)
		end if
		choice_response = null
		if in_main == true or sm == 0  then 
			menu_response = user_input(color.green+"[ SELECT MENU ] "+color.cap+color.grey+"* exit to return*"+color.cap+color.white+" --> ")
			if menu_response == "exit" then 
				selecting = false
				return null
			end if
			sm = menu_response.val
		end if
		
		if sm == 0 and in_main == false then return
		if sm > 0 and in_main == false then 
			choice_response	= user_input(color.green+"[ CHOOSE OPTION ] "+color.cap+color.grey+"* Press 0 to return*"+color.cap+color.white+" --> ")
			if choice_response.val == 0 then 
				sm = 0
				continue
			end if 
			if choice_response.val > options.len then continue
			if choice_response.val == 0 then sm = 0

			attack_choice = user_input(color.orange+"[ CONFIRM ] \n"+color.white+"1.)"+color.cap+color.purple+" Surf Mode\n"+color.white+"2.)"+color.cap+color.red+" Remove Object\n"+color.white+"-- "+color.cap+color.grey+" * Press any to return *"+color.cap+color.white+" --> ")
			attack_choice = attack_choice.val
			if attack_choice == 1 then
				chosen_obj = options[choice_response.val-1] 
				selected_obj = chosen_obj[0]
				selecting = false
				return selected_obj
			else if attack_choice == 2 then 
				Core.remove(sm, choice_response)
			end if
		end if
	end while
end function
///============================
///======================= OBJ ADD =========================////
///============================
Core.add = function(object, pass = null) // : map
	if (object isa ShellObject) == true then 
		globals.Shells = globals.Shells.push([object, "captured"])
	else if (object isa CompObject) == true then 
		globals.Computers = globals.Computers.push([object, "captured"])
	else if (object isa FileObject) == true then 
		globals.Files = globals.Files.push([object, "captured"])
	else 
		return print(warning+" unable to add object to the pool: "+typeof(object))
	end if
	if pass then return
	Current_Object = object
end function
//data.exports = @Core.add
///============================
///======================= OBJ REMOVE  =========================////
///============================
Core.remove = function(type, index) // : number, : number
	t = "unknown"
	if type == 1 then 
		t = "shell"
		globals.Shells = globals.Shells.remove(index)
	else if type == 2 then
		t = "pc" 
		globals.Computers = globals.Computers.remove(index)
	else if type == 3 then 
		t = "file"
		globals.Files = globals.Files.remove(index)
	else 
		return print(warning+" unable to remove "+t+" object from the pool")
	end if
	
end function
///============================
///======================= cd  =========================////
///============================
Core["cd"] = function(obj, p)
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	base = null
	if not p then
		if Utils.user(obj) == "root" then globals.Current_Path = "/root"
		if Utils.user(obj) != "root" then globals.Current_Path = "/home/"+Utils.user(obj) 
		return globals.Current_Path
	else
		base = obj.File(globals.Current_Path)
		//if not base then base = user_input(">")
		if not base then return obj.File("/")
	end if
	dir = null
	if p == "./" then 
		dir = base.parent
	else if p == "/" then 
		dir = obj.File("/")
	else if p != "/" and base.name == "/" then 
		dir = obj.File("/"+p)
	else if p[0] == "/" then
		dir = obj.File(p)
	else if p != null then
		dir = obj.File(base.path+"/"+p)
	end if

	if dir == null then return print("No directory found")
	globals.Current_Path = dir.path
	return globals.Current_Path
end function
///============================
///======================= me  =========================////
///============================
Core["me"] = function(obj,act, p2)
	obj = Utils.handle(obj)
	if act != "-d" and act != "-a" then return print(Utils.user(obj))
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	if typeof(obj) == "file" then return print(error+"invalid operation")
	task = null
	if not p2 then return print(warning+"no user specified")
	label = "removed"
	if act == "-d" then
		task = obj.delete_user(p2, true)
	else 
		task = obj.create_user(p2, "tunafish")
		label = "added"
	end if
	if typeof(task) == "string" then return print(task)
	print(p2+" was "+label)
end function

///=====================================================////
////////////////////////// SHELL ///////////////////////
///====================================================////
///============================
// =======================  terminal =======================
Core["terminal"] = function(obj, _)
	obj = Utils.handle(obj)
	if typeof(obj) != "shell" and typeof(obj) != "ftpshell" then return print("-t cant launch")
	obj.start_terminal
	exit(); // ty tux
	//return obj.start_terminal
end function
///============================
// =======================  sudo =======================
///============================
Core["sudo"] = function(s = get_shell, arg, arg2=null, arg3=null)
	if typeof(s) == "map" then s = Utils.handle(s)
	computer = s.host_computer
	inputPass = user_input("Password: ", true)
	if arg == "-u" then s = get_shell(arg2, inputPass)
	if arg == "-s" or arg == "-l" then s = get_shell("root", inputPass)
	if not s then return print(color.orange+"AUTH FAIL")
	if arg == "-l" then 
		program = computer.File(arg2)
		if not program then return print(arg2 + " not found.")
		if not arg3 then s.launch(arg2)
		if arg3	then s.launch(arg2, arg3)
	end if
	so = null
	if typeof(s) == "shell" then 
		so = new ShellObject
		so.init(s)
	end if
	return so
end function
///============================
// =======================  build =======================
///============================
Core["build"] = function(obj, pathFile, targFilePath, fileName)
	if globals.debug then print("path: "+ pathFile+"\nfileName: "+fileName)
	obj = Utils.handle(obj)
	if typeof(obj) != "shell" then return print(error+"Only shells can build")
	if pathFile[0] != "/" then pathFile = Utils.pth(pathFile)
	if targFilePath[0] != "/" then targFilePath = Utils.pth(targFilePath)
	// single arg
	create = obj.build(pathFile, targFilePath, fileName)
	if create.len > 1 then return print(warning+create)
	print(color.white+fileName+color.cap+" compiled at path "+color.yellow+pathFile)
end function
///============================
// =======================  launch =======================
///============================
Core[".exe"] = function(obj, p, data = null)
	obj = Utils.handle(obj)
	if typeof(obj) != "shell" and typeof(obj) != "ftpshell" then return print(color.yellow+"exe: cant launch")
	dirs = ["/home/guest", "/bin", "/home/guest/Desktop/.cache"]
	file = null
	if p == "-e" then 
		for file in dirs 
			f = obj.host_computer.File(file+"/eel")
			if f then 
				file = f
				break
			end if
		end for
		if typeof(file) == "file" then obj.launch(file.path, "-a")
	else if p == "-p" then 
		for file in dirs 
			f = obj.host_computer.File(file+"/payload")
			if f then 
				file = f
				break
			end if
		end for
		if typeof(file) == "file" then 
			if data then obj.launch(file.path, data)
			if not data then obj.launch(file.path)
		else
			pth = user_input("path:")
			obj.launch(pth)
		end if
	else if p == "-s" then 
		for file in dirs 
			f = obj.host_computer.File(file+"/ss")
			if f then
				print("found ss: "+f.path) 
				file = f
				break
			end if
		end for
		if typeof(file) == "file" then obj.launch(file.path, "-a")
	else 
		if p[0] != "/" and Current_Path != "/" then p = Current_Path+"/"+p
		if data then 
			obj.launch(p, data)
		else
			obj.launch(p)
		end if
		file = ";)"
	end if
	if file == null then print(warning+color.yellow+"<i>launch binary not found on target machine")
	return data
end function
///============================
// =======================  service =======================
///============================
Core["service"] = function(object, action, service = null, force = null)
	print(init+color.yellow+"Service Manager")
	obj = Utils.handle(object)
	ip = obj.host_computer.local_ip
	if action == "-l" then
		svs = ["libchat.so", "librepository.so", "librshell.so", "libsql.so","libhttp.so","libftp.so","libssh.so"]
		svs_dis = null
		height = 0
		for s in svs
			library = get_library(s)
			status = "----->"+color.red+" missing"+color.cap+color.grey+" X"
			if library then 
				running = null
				router = get_router
				ports = router.device_ports(ip)
				fwdPorts = router.used_ports
				fwd = color.grey+" UNKNOWN"
				for p in ports
					srv = router.port_info(p)
					if not srv then continue
					lan = p.get_lan_ip
					//if lan == ip then continue
					service_parsed = srv.split(" ")
					service_lib = service_parsed[0]
					if ("lib"+service_lib+".so" == s) and (lan == ip) then 
						fwd = color.green+" INTERNAL"
					end if
				end for
				for p in fwdPorts
					srv = router.port_info(p)
					if not srv then continue
					lan = p.get_lan_ip
					//if lan == ip then continue
					service_parsed = srv.split(" ")
					service_lib = service_parsed[0]
					if ("lib"+service_lib+".so" == s) and (lan == ip) then 
						fwd = color.red+" EXTERNAL"
					end if
				end for
				//print(format_columns(info))
				test = library.stop_service
				if test == 1 then 
					library.start_service
					running = true
				end if
				// if running then shrug
				if not running then 
					status = "----->"+color.yellow+" offline"+color.cap+fwd
				else 
					status = "----->"+color.green+" online"+color.cap+fwd
				end if
			end if
			svs_dis = color.white+s+color.cap+" "+status+"\n"+svs_dis
		end for
		return print(color.blue+color.fill+"\n"+format_columns(svs_dis))
	else if (action == "-s" or action == "-k") and (service == "libhttp.so") and (force != null) then
		run = Utils["webmanager"]
		run(obj, force)
	end if
	srv = null
	srv = get_library(service)
	if not srv then return print(warning+service+" not found")
	act = null
	locals.router = get_router
	if not router then return print(error+" An error occured")
	ports = router.device_ports(obj.host_computer.local_ip) // these appear to be forwarded ports ?
	act_label = "install"
	if action == "-i" and service then
		print(color.grey+"installing: <i>"+service) 
		act = srv.install_service
	else if action == "-s" and service then
		print(color.grey+"Starting: <i>"+service) 
		act = srv.start_service
		act_label = "start"
	else if action == "-k" and service then
		print(color.white+"Stopping: <i>"+service)
		act_label = "kill" 
		act = srv.stop_service
	end if
	if typeof(act) == "string" then 
		return print(warning+"<b>"+color.red+act)
	else if act == 1 then 
		print(act_label+" "+color.white+service+color.cap+" ---> "+color.green+"<b>OK")
	else 
		return print(warning+"failed to "+act_label+" "+service)
	end if
end function


///=====================================================////
////////////////////////// COMPUTER ///////////////////////
///====================================================////
///============================
// =======================  ps =======================
///============================
Core["ps"] = function(obj)
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	output = obj.show_procs
	return print(format_columns(output))
end function
///============================
// =======================  kill =======================
///============================
Core["kill"] = function(obj, pid)
	obj = Utils.handle(obj)
	pid = pid.to_int
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	if typeof(pid) != "number" then return print(warning+" The PID must be a number\n")
	output = obj.close_program(pid)
	if output == true then return print("Process " + pid + " closed");
	if output then return print(output)
end function
///============================
// =======================  pw =======================
///============================
Core["pw"] = function(obj, user)
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	inputMsg = "Changing password for user " + user +".\nNew password:"
	inputPass = user_input(inputMsg, true)
	output = obj.change_password(user, inputPass)
	if typeof(output) != "string" then return print(user+" password modified OK")
	return print(output)
end function
///============================
// =======================  touch =======================
///============================
Core["touch"] = function(obj, pathFile, fileName)
	if globals.debug then print("path: "+ pathFile+"\nfileName: "+fileName)
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	if fileName == "" or fileName == null then 
		if globals.debug then print("tch: c1")
		destParent = Utils.pth(pathFile) // define destination
		destParse = destParent.split("/") // parse
		fileName = destParse[destParse.len-1] // get name
		pathFile = destParent.split(fileName)[0] // use name to get parent
	end if
	// single arg
	create = obj.touch(pathFile, fileName)
	file = obj.File(pathFile+"/"+fileName)
	if file == null then return print(warning+"touch: failed")
	print(color.white+fileName+color.cap+" created at path "+color.yellow+pathFile)
end function
///============================
// =======================  mkdir =======================
///============================
Core["mkdir"] = function(obj, pathFile, fileName)
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	if fileName == "" or fileName == null then 
		if globals.debug then print("mkdir: c1")
		destParent = Utils.pth(pathFile) // define destination
		destParse = destParent.split("/") // parse
		fileName = destParse[destParse.len-1] // get name
		pathFile = destParent.split(fileName)[0] // use name to get parent
	end if
	file = obj.create_folder(pathFile, fileName)
	result = obj.File(pathFile+"/"+fileName)
	if not result then return print("mkdir: failed")
	print(fileName+" created at path "+ pathFile)
end function
///============================
// ======================= SCP =========================
///============================
Core["scp"] = function(remote, type, origPath, destPath=null)
	home_shell = null;remote_shell = null;
	home_shell = globals.Shells[0][0];
	home_shell = Utils.handle(home_shell);
	if not destPath then destPath = Current_Path
	if origPath[0] != "/" then origPath = Utils.pth(origPath)
	if typeof(home_shell) == "ftpshell" then return print(warning+"object is of type ftpshell")
	remote_shell = Utils.handle(remote)
	if type == "-d" then 
		remote_shell.scp(origPath, destPath, home_shell)
	else if type == "-u" then 
		home_shell.scp(origPath, destPath, remote_shell)
	else 
		return print("an error occured")
	end if
end function
///============================
// ======================= PUT =========================
///============================
Core["put"] = function(remote, origPath, destPath)
	if typoef(remote) != "ftpshell" then return print(warning+"object is not of type ftpshell")
	home_shell = null;
	remote_shell = null;
	home_shell = globals.Shells[0][0];
	home_shell = Utils.handle(home_shell);
	remote_shell = Utils.handle(remote)
	home_shell.put(origPath, destPath, remote_shell)
end function
///============================
// ======================= GET =========================
///============================
Core["get"] = function(remote, origPath, destPath)
	if typoef(remote) != "ftpshell" then return print(warning+"object is not of type ftpshell")
	home_shell = globals.Shells[0][0];
	home_shell = Utils.handle(home_shell);
	remote_shell = Utils.handle(remote)
	remote_shell.put(origPath, destPath, home_shell)
end function
///============================
// ======================= SSH =========================
///============================
Core["ssh"] = function(shell, connect_string, ip, port = 22)
	object = Utils.handle(shell)
	if typeof(object) != "shell" then return print(" no shell detected")
	connect_string = connect_string.split("@")
	service = object.connect_service(ip, port, connect_string[0], connect_string[1])
	so = null
	if typeof(service) == "shell" then
		Utils.paired_msg 
		so = new ShellObject
		so.init(service)
	end if 
	return so
end function
///============================
// ======================= FTP =========================
///============================
Core["ftp"] = function(object, connect_string, ip, port = 21)
	object = Utils.handle(object)
	if typeof(object) != "shell" or typeof(object) == "ftpshell" then return print(" no shell detected")
	if not object then object = Global_Shells[0][0]
	connect_string = connect_string.split("@")
	service = object.connect_service(ip, port, connect_string[0], connect_string[1], "ftp")
	so = null
	if typeof(service) == "ftpshell" then
		Utils.paired_msg 
		so = new ShellObject
		so.init(service)
	end if 
	return so
end function
///============================
// ======================= SECURE =========================
///============================
Core["secure"] = function(obj, type = "-h")
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	if Utils.user(obj) != "root" then return print("You need to be root to run this operation")
	root = obj.File("/")
	if not root then return print("no root?")
	chO = root.chmod("o-wrx", true);wait(0.1);
	if chO.len > 1 then print(warning+" failed to adjust scope Other to /\n"+chO)
	mail=null;bnk=null;
	if type == "-s" then
		chG = root.chmod("g-wrx", true).len
		chU = root.chmod("u-wrx", true).len
		if chG > 1 then print(warning+" failed to adjust scope Group to /\n"+chG)
		if chU > 1 then print(warning+" failed to adjust scope User to /\n"+chU)
		mail = obj.File("/root/Config/Mail.txt")
		bnk = obj.File("/root/Config/Bank.txt")
		if obj.File("/home") then obj.File("/home").delete
	else if type == "-p" then
		Utils.patch_sys(obj)
		return 
	else 
		cfg = obj.File("/home/2NA/Config")
		if cfg then
			ch = null 
			ch = cfg.set_owner("root", true).len;wait(0.1);
			if ch > 1 then print(ch)
			ch = cfg.set_group("root", true).len;wait(0.1);
			if ch > 1 then print(ch)
		end if
		wait(0.1)
		mail = obj.File("/home/2NA/Config/Mail.txt")
		bnk = obj.File("/home/2NA/Config/Bank.txt")
		if mail then mail.delete
		if bnk then bnk.delete
		files = ["/sys", "/boot", "/lib"]
		for file in files
			if obj.File(file) then obj.File(file).chmod("u-wx", true)
		end for
		
	end if
	if mail then
		print(color.yellow+"<b>Mail deleted!!") 
		mail.delete
	end if
	if bnk then
		print(color.yellow+"<b>Bank deleted!!")  
		bnk.delete
	end if
	wait(0.2)
	pw = obj.File("/etc/passwd")
	del = "o"
	if pw then del = pw.delete
	wait(0.1)
	if del.len > 1 then print("Deleted /etc/passwd")
end function

///=====================================================////
///////////////////////////// FILE /////////////////////////
///====================================================////
///============================
// =======================  ls =======================
Core["ls"] = function(obj)
	p = globals.Current_Path
	if not p then p = current_path
	print(init+"fs: "+color.yellow+p)
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then 
		folder = obj.host_computer.File(p)
	else if typeof(obj) == "computer" then 
		folder = obj.File(p)
	else if typeof(obj) == "file" then 
		folder = obj
	end if
	if folder == null then return print("ls no file or directory found")
	//if not folder.has_permission("r") then return print("You do not have read access for "+folder)
	folder_path = p
	sub_files = folder.get_folders + folder.get_files
	output = ""
	if not sub_files then
		output = "*"+color.grey+"<i>This Directory Has No Content</i>"+color.cap+"*  Use cmd: "+color.white+"<b>cd ./</b>"+color.cap+" to navigate to previous directory"
	else if sub_files.len > 0 then 
		output = color.grey+"NAME"+color.cap+" "+color.white+"TYPE"+color.cap+" "+color.grey+"OWNER"+color.cap+" "+color.white+"GROUP"+color.cap+" "+color.grey+"SIZE"+color.cap+" "+color.white+"PERMISSIONS"+color.cap
	end if
	for f in sub_files
		if output.len > 0 then 
			output = output + "\n"
		end if
		file_type = color.cyan+"txt"+color.cap
		if f.is_folder then file_type = color.purple+"dir"+color.cap
		if f.is_binary and not f.is_folder then file_type = color.grey+"bin"+color.cap
		file_name = f.name
		permission = f.permissions
		output = output +color.white+ file_name+color.cap+ " "+file_type+" " +color.orange+ f.owner +color.cap+ " " +color.green+ f.group +color.cap+ " "+ color.cyan+ f.size +color.cap +" "+ color.white+permission+color.cap
	end for
	if not sub_files then return print(output)
	print(format_columns(output))
end function
///============================
// =======================  chmod =======================
Core["chmod"] = function(obj, recursive, perms, path_to_file)
	rec = false
	if recursive == "-r" then 
		rec = true
	else if recursive == "-d" then 
		rec = false
	end if
	if path_to_file[0] != "/" then path_to_file = Utils.pth(path_to_file)
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	file = obj.File(path_to_file)
	if file == null then return print("cannot find file "+path_to_file)
	output = file.chmod(perms, rec)
	if output.len > 1 then print(output)
end function
///============================
// =======================  chgrp =======================
Core["chgrp"] = function(obj, recursive, perms, path_to_file)
	if perms == null or path_to_file == null then return print(warning+"invalid usage")
	rec = false
	if recursive == "-r" then rec = true
	if path_to_file[0] != "/" then path_to_file = Utils.pth(path_to_file)
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	file = obj.File(path_to_file)
	if file == null then return print("cannot find file "+path_to_file)
	output = file.set_group(perms, rec)
	if output.len > 1 then print(output)
end function
///============================
// =======================  chown =======================
Core["chown"] = function(obj, recursive, perms, path_to_file)
	if perms == null or path_to_file == null then return print(warning+"invalid usage")
	rec = false
	if recursive == "-r" then rec = true
	if path_to_file[0] != "/" then path_to_file = Utils.pth(path_to_file)
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	file = obj.File(path_to_file)
	if file == null then return print("cannot find file "+path_to_file)
	output = file.set_owner(perms, rec)
	wait(0.1)
	if output then print(output)
end function
///============================
// =======================  cat =======================
Core["cat"] = function(obj, pathFile)
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	if pathFile[0] != "/" then pathFile = Utils.pth(pathFile)
	file = obj.File(pathFile)
	if file == null then return print("cat: file not found: "+pathFile)
	if file.is_binary then return print("cat: can't open " + file.path + ". Binary file")	
	if not file.has_permission("r") then return print("cat: permission denied")
	print(file.get_content)
end function
///============================
// =======================  mvdir =======================
///============================
Core["move"] = function(obj, targFilePath, pathFile, fileName)
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	
	if targFilePath[0] != "/" then targFilePath = Utils.pth(targFilePath)
	if pathFile[0] != "/" then pathFile = Utils.pth(pathFile)
	if typeof(obj) == "file" then return obj.move(targFilePath, fileName)

	targ = obj.File(targFilePath)
	if targ == null then return print("mv: no file found")
	file = targ.move(pathFile, fileName)
	if typeof(file) == "string" then return print(file)
	print(fileName+" created at path "+ pathFile)
end function
///============================
// =======================  copy =======================
Core["copy"] = function(obj, targFilePath, pathFile, fileName)

	obj = Utils.handle(obj)

	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	
	if targFilePath[0] != "/" then targFilePath = Utils.pth(targFilePath)
	if pathFile[0] != "/" then pathFile = Utils.pth(pathFile)
	if typeof(obj) == "file" then return obj.copy(pathFile, fileName)

	targ = obj.File(targFilePath)
	if targ == null then return print("mv: no file found")
	file = targ.copy(pathFile, fileName)
	if file == false then return print("mv: failed to move")
	print(fileName+" created at path "+ pathFile)
end function
///============================
// =======================  rm =======================
///============================
Core["rm"] = function(obj, pathFile)
	obj = Utils.handle(obj)
	if typeof(obj) == "file" then return obj.delete
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	if pathFile[0] != "/" then pathFile = Utils.pth(pathFile)
	file = obj.File(pathFile)
	if file == null then return print("rm: cant find file")
	if file.has_permission("w") == false then return print("rm: cant write to file")
	n = file.name
	del = file.delete
	wait(0.1)
	if del.len < 1 then print("deleted "+n)
end function

/////////////////////////////////////////////////////////////
//////////////////    FILE EDIT    //////////////////////
////////////////////////////////////////////////////
inputs = {}
inputs.pos = {}
inputs.pos.setY = function(lineIndex, data)
	current_line = inputs.pos.y
	length = data.len-1
	// down
	if lineIndex < 0 and length > 0 and inputs.pos.y != 0 then  // up
		print("moving: up")
		inputs.pos.y = inputs.pos.y-1
	else if length > 0 and lineIndex > 0 and inputs.pos.y != length then // down
		print("moving: down")
		inputs.pos.y = inputs.pos.y+1
	end if
	//if globals.debug == true then print("setY: input "+lineIndex+" global: "+inputs.pos.y+"\n-----")
	inputs.pos.x = 0
	return inputs.pos.y
end function
inputs.pos.setX = function(linePos, data)
	current_position = data[inputs.pos.y-1] // gets the line we are editing
	print("SET X line: "+current_position)
	length = current_position.len-1
	if linePos < 0 and length > 0 and inputs.pos.x != 0 then // left
		print("moving: left")
		inputs.pos.x = inputs.pos.x-1
	else if length > 0 and linePos > 0 and inputs.pos.x != length then // right 
		print("moving: right")
		inputs.pos.x = inputs.pos.x+1
	end if
	//if globals.debug == true then print("setX: input "+linePos+"\nglobal: "+inputs.pos.x+"\n-----")
	return inputs.pos.x
end function
Core["edit"] = function(obj, pathFile, clean = null)
	inputs.pos.x = 0;inputs.pos.y = 0;cI = 0;bool = false;f=null;
	if clean == "-c" then bool = true
	obj = Utils.handle(obj)
	if pathFile[0] != "/" then pathFile = Utils.pth(pathFile)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	if typeof(obj) == "computer" then obj = obj.File(pathFile)
	if typeof(obj) == "file" then 
		f = obj
		if globals.debug then print("edit: file object passed "+f.path)
	else
		f = obj.File(pathFile)
	end if
	if f == null then
		return print(warning+" edit: no file found")
	else if f.has_permission("r") == false or f.has_permission("w") == false then 
		return print(warning+"edit: error with file permissions")
	end if
	
	editing = true;saving = false;raw_content = f.get_content;new_content = null
	valid_inputs = ["_","LeftArrow","RightArrow","DownArrow","UpArrow"]
	invalid_inputs = ["LeftShift","RightShift", "Tab", "LeftControl", "RightControl", "LeftAlt", "RightAlt"]
	parse = null
	while editing == true 
		display = null;lineIndex = inputs.pos.y;index = inputs.pos.x;cI = 0
		if new_content == null then 
			new_content = raw_content;parse = new_content.split(char(10))
		end if
		if globals.debug then print("Initial data: "+parse)
		count = 0
		for line in parse
			display = display + "\n"+count+".) "+line;count = count+1
		end for
		print(color.blue+color.fill+"\n"+color.white+"Editing: "+color.cap+color.yellow+pathFile+color.cap+"\n"+display)
		//if globals.debug then print("X: "+index+"\nY:"+lineIndex)
		controller = null;controller = user_input("----INPUT: "+controller+"\nX: "+index+"\nY: "+lineIndex+"\n-----\nF1 --> save\nESC --> return\n: ", bool, true)
		//controller = user_input("|", false, true)
		//if globals.debug then print("INPUT: "+controller+"\nX: "+index+"\nY: "+lineIndex)
		//if globals.debug then print(color.fill+"\nline to edit: "+l+"\nindex: "+l[inputs.pos.x])
		if valid_inputs.indexOf(controller) then
			if globals.debug then print("controller input") 
			if controller == "LeftArrow" then 
				index = inputs.pos.setX(-1, parse)
			else if controller == "RightArrow" then 
				index = inputs.pos.setX(1, parse)
			else if controller == "UpArrow" and lineIndex != 0 and lineIndex > 0 then 
				lineIndex = inputs.pos.setY(-1, parse)
			else if controller == "DownArrow" and lineIndex > -1 then 
				lineIndex = inputs.pos.setY(1, parse)
			end if
			l = parse[inputs.pos.y]
			if globals.debug then print("line to edit: "+l)
		else
			l = parse[inputs.pos.y]
			if globals.debug then print("line to edit: "+l)//+"\nindex: "+l[inputs.pos.x])
			if controller == "Escape" then 
				if globals.debug then print("c1")
				break
			// ENTER
			else if controller == "" then
				if globals.debug then print("c2") 
				parse.push("")
			// SAVE
			else if controller == "F1" then
				saving = true 
				break
			else if not invalid_inputs.indexOf(controller) then
				mut_line = ""
				if l.values.len == 0 then 
					if globals.debug then print("<color=green>this happens")
					mut_line=controller
				else 
					if globals.debug then print("<color=red>this happens")					
				end if
				for chars in l.values
					if globals.debug then print("cI?: "+cI)
					if cI == inputs.pos.x then
						if globals.debug then print("count == pos : adding "+chars+" to: "+controller) 
						if controller == "Backspace" then
							mut_line = mut_line+""
							inputs.pos.x = inputs.pos.x-1
						else if controller == "Spacebar" then
							mut_line = mut_line+" "
						else
							//inputs.pos.x = inputs.pos.x+1 // wow this was bad
							mut_line = mut_line+chars+controller//+chars//+chars+mut_line
						end if
					else
						mut_line = mut_line+chars
					end if
					cI = cI +1
				end for
				if controller != "Backspace" and controller != "" then inputs.pos.x = inputs.pos.x+1
				//if inputs.pos.x != 0 then inputs.pos.x = inputs.pos.x-1
				if globals.debug then print("mut line: "+mut_line)
				parse[inputs.pos.y] = mut_line
				if globals.debug then print("parse line: "+parse[inputs.pos.y])
				if globals.debug then print("c3") 
			end if 
		end if
	end while
	if saving then
		set = null
		newcount = 0
		for p in parse
			if globals.debug then print("p: "+p) 
			if p == char(10) or p == "\n" or p == "" then 
				set = set+char(10)
			else
				if newcount == 0 then
					set = set+p
				else
					set = set+char(10)+p
				end if
			end if
			newcount = newcount+1
		end for
		save = f.set_content(set)
		if typeof(save) != "string" then return print(f.name+" was saved!")
	end if
end function
// =======================  move =======================

///============================
// =======================  ping =======================
Core["ping"] = function(shell, ip)
	obj = Utils.handle(shell)
	result = obj.ping(ip)
	if result then
		if typeof(result) == "string" then
			print(result) 
		else
			print("Ping successful")
		end if
	else
		print("ip unreachable");
	end if
end function

// ======================= SERVICES =========================
///============================
// ======================= sniff =========================
Core["sniff"] = function()
	if globals.Mode then return print(warning+"program is operating at cfg:"+globals.Mode)
	print(init+" Listening for connections . . .")
	output = meta.sniffer
	print(output)
end function
///============================
// =======================  iwlist =======================
///============================
Core["iwlist"] = function(obj, net)
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	if devices == null or devices.indexOf(net) == null then return print(warning+"iwlist: Network device not found")
	if params[0].indexOf("eth") != null then exit("iwlist: ethernet cards not supported for this command")
	networks = obj.wifi_networks(net)
	if networks == null then return print(warning+"iwlist: invalid usage")
	info = "BSSID PWR ESSID"
	for network in networks
		info = info + "\n" + network
	end for
	print(format_columns(info))
end function
///============================
// =======================  ifconfig =======================
///============================
// Usage: ifconfig [net interface] [ip address] gateway [ip address]
Core["ifconfig"] = function(obj, addr = null, gate = null, device = null)
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	if not addr then
		router = get_router    
		if obj.is_network_active then
			lip = obj.local_ip
			pip = router.public_ip
			gw = obj.network_gateway
			if obj.active_net_card == "WIFI" then		    
				output = "\nConnected to Wi-Fi:\nEssid: " + router.essid_name + "\nBssid: " + router.bssid_name
			else
				output = "\nEthernet connection:"    
			end if
		else
			lip = "0.0.0.0"
			pip = "0.0.0.0"
			gw = "0.0.0.0"
			output = "\nNot connected to the network."
		end if
		print( output + "\n----------------\nPublic IP: " + pip + "\nLocal IP: " + lip + "\nGateway: " + gw + "\n")
	else 
		if not gate or not device then return print(error+"ifconfig invalid args")
		if not is_valid_ip(addr) then return print(warning+"ifconfig: <b>invalid ip address")
		if not is_valid_ip(gate) then return print(warning+"ifconfig: <b>invalid gateway")
		output = obj.connect_ethernet(device, addr, gate)
		if output.len > 0 then print(output)
	end if
end function


///============================
// =======================  iWconfig =======================
///============================
//Usage: iwconfig [net device] [bssid] [essid name] [pass key]
Core["iwconfig"] = function(obj, net, bss, ess, pass)
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	//command: iwconfig
	devices = obj.network_devices
	if devices == null or devices.indexOf(net) == null then return print("iwconfig: Network device not found")
	status = computer.connect_wifi(net, bss, ess, pass)
	if typeof(status) == "string" then print(status)
end function
///============================
// =======================  airmon =======================
///============================
Core["airmon"] = function(obj, option, device)
	if not crypto then return print("Error: Missing crypto library")
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	formatOutput = "Interface Chipset Monitor_Mode\n"
	if option != "start" and option != "stop" then return print(warning+"invalid arguments, [start|stop]")
	output = crypto.airmon(option, device)
	if not output then return print(warning+"airmon: " + device + " not found")
	if typeof(output) == "string" then return print(output)
	print(format_columns(formatOutput + obj.network_devices))
end function
///============================
// =======================  aireplay =======================
///============================
Core["aireplay"] = function(bssid, essid)
	if not bssid or not essid then return print(error+" invalid usage")
	if not crypto then return print(error+"Missing crypto library")
	result = crypto.aireplay(bssid, essid)
	if typeof(result) == "string" then return print(result)
end function
///============================
// =======================  aireplay =======================
///============================
Core["aircrack"] = function(obj, pathFile)
	//command: aircrack
	if not crypto then return print(error+"Missing crypto library")
	if pathFile[0] != "/" then pathFile = Utils.pth(pathFile)
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	file = obj.File(pathFile)
	if file == null then return print(warning+"aircrack: file not found: "+pathFile)
	if not file.is_binary then return print(warning+"aircrack: Can't process file. Not valid filecap.")		
	if not file.has_permission("r") then exit(warning+"aircrack: permission denied")

	key = crypto.aircrack(file.path)
	if key then 
		print("KEY FOUND! [" + key + "]" )
	else 
		print("aircrack: Unable to get the key" )
	end if
end function

Core["lib_catch"] = function(obj, lib, libVersion)
	ip = null
	if lib == "-r" then 
		ip = Utils.router_catch(obj, libVersion)
	else 
		ip = Utils.lib_catch(obj, lib, libVersion)
	end if
	if ip then return Core.Probe(obj, ip)
	return print(error+"with cmd: lib")
end function
///============================
// =======================  apt-get =======================
///============================
PendingUpdating = function(obj, folderPath)
	pc = obj.host_computer
	apt = include_lib("/lib/aptclient.so")
	if not apt then
		apt = include_lib(current_path + "/aptclient.so")
	end if
	pendingUpdate = []
	
	dirs = [folderPath, "/lib/cheese"]
	
	for dir in dirs
		target_folder = pc.File(dir)
		if target_folder then 
			for file in target_folder.get_files
				output = apt.check_upgrade(file.path)
				if output == true then pendingUpdate.push(file.name)
			end for
		end if
	end for
	return pendingUpdate
end function 

//  shell: Shell
// (action) p1: action: string
// (lib) p2: string | null
// (force) p3: boolean | null

// i dont even want to look at this pos
///============================ 
// =======================  apt-get =======================
///============================
Core["git"] = function(shell, cmd, param=null)
	shell = Utils.handle(shell)
	aptclient = include_lib("/lib/aptclient.so")
	if not aptclient then
		aptclient = include_lib(current_path + "/aptclient.so")
	end if
	if not aptclient then return print(error+ " Missing aptclient.so library in the /lib path or the current folder")
	if cmd == "-u" then // update
		print("Updating package lists...")
		output = aptclient.update
		if output then print(output)
	else if cmd == "--" then // upgrade
		pendingPackages = PendingUpdating(shell, "/lib") + PendingUpdating(shell, "/bin")
		if pendingPackages.len == 0 then return print("c1: No updates needed")
		pkgs = ""
		c = 1
		for itemPackage in pendingPackages
			pkgs = pkgs +c+".)"+color.white + itemPackage+"\n"
			c = c+1
		end for
		print("The following packages will be updated:\n"+pkgs)
		force = null
		option = null
		if param != "-f" then 
			option = user_input("\nDo you want to continue?(y/n): ")
			if option != "y" then return print("Exiting . . .")
		end if
		counter = 0
		for itemPackage in pendingPackages
			output = aptclient.install(itemPackage)
			if output == true then
				counter = counter + 1
			else if output then
				print(output)
			end if
		end for
	print(counter + " packages updated")
	else if param then 
		if cmd == "install" then 
			print("Downloading " + param);output = aptclient.install(param)
			if output == true then print(param + " installed")
			print(output)
		else if cmd == "search" then 
			print(aptclient.search(param));
		else if cmd == "show" then		
			print(aptclient.show(param));
		else if cmd == "addrepo" then
			port = 1542
			output = aptclient.add_repo(param)
			if output then print(output)
			print("Repository " + param + " added succesfully.\nLaunch apt with the update option to apply the changes")
		else if cmd == "delrepo" then
			output = aptclient.del_repo(param)
			if output then print(output)
			print("Repository " + param + " removed succesfully.\nLaunch apt with the update option to apply the changes")
		else if cmd == "update" then 
			output = aptclient.install(param)
			if output == true then print("updated: "+param)
		end if
	end if
end function
//////////////////////////////////////////////////////////////////////////////  
///======================== NET SESSION =================================///
//////////////////////////////////////////////////////////////////////////
///============================
///============================ HANDLER =====================///
// obj: shellobject , p1: --|ip|domain, p2: *|port
Core["Entry"] = function(obj, p1, p2 = null)
	if globals.Mode then return print(warning+"program is operating cfg: <b>"+color.white+globals.Mode)
	addr = null
	port = null
	// reg, random,
	if not p2 then
		if p1 == "dungeonseeker" then return NPC.dungeon_seeker
		print("p1: "+p1)
		if p1 == "-r" then 
			addr = Utils.random_ip
		else 
			addr = p1
		end if
		if globals.debug then print("net entry: c1") 
	else // random specific port
		if p1 != "-r" then return print(warning+"entry: <i>invalid usage") 
		if globals.debug then print("net entry: c2") 
		addr = Utils.player_ip(p2)
	end if
	return Core.Probe(obj, addr)
end function
///============================
///============================ MAP =====================///
///============================
Core.map = function(addr)
	isDomain = null
	if not is_valid_ip(addr) or not is_lan_ip(addr) then
		isDomain = nslookup(addr)
		if is_valid_ip(isDomain) then addr = isDomain
	end if
	if not isDomain and not is_valid_ip(addr) then return print(warning+" not a valid IP")
	addr_label = "HIDDEN"
	if globals.anonymous == false then addr_label = addr
	router = null;ports = null;isLanIp = is_lan_ip(addr);info = null;num = 0;
	if isLanIp then 
		print("lan detected")
		router = get_router;
		if not router then return print(error+" An error occured")
		ports = router.device_ports(addr) // these appear to be forwarded ports ?
	else 
		router = get_router(addr); 
		if not router then return print(error+" An error occured")
		ports = router.used_ports
	end if
		devices = router.devices_lan_ip 	// any machine on the network reachable by ping on this address 
	//optional router attack
	if not ports or ports.len == 0 then return print(warning+"no ports found")
	for port in ports
		service = router.port_info(port)
		if not service then continue
		service_parsed = service.split(" ")
		service_lib = service_parsed[0]
		service_version = service_parsed[1]
		status = color.green+"open"+color.cap
		lan = port.get_lan_ip
		number = port.port_number
		if (port.is_closed and not isLanIp) then status = color.red+"closed"+color.cap
		//choices = choices + "\n"+color.cyan + num+".) "+color.cap+color.purple+ lan +color.cap+color.white+ " " + number +color.cap+color.green +" " + service_lib
		num = num+1	
		info = info + color.cyan+service_lib+color.cap + " " + status + " " +color.grey+service_version+color.cap + " " + color.purple+lan+color.cap+color.white+" "+number+"\n"
	end for
	print(color.blue+color.fill+"\n"+color.blue+"><>"+color.cap+" "+addr_label+color.cap+" "+color.grey+number+color.cap+" Router: <b>v"+color.white+router.kernel_version)
	if globals.anonymous == false then Utils.who(addr)
	print(color.green+"><> "+color.cap+format_columns("LIB STATE VERSION LAN PORT")+color.green+" ><>")
	print(format_columns(info))
	//print(color.blue+color.fill); print(format_columns(choices)); print(color.blue+color.fill)
end function
///============================
///============================ PROBE =====================///
///============================
Core["Probe"] = function(object, addr, extended = null)
	isDomain = null
	if not is_valid_ip(addr) or not is_lan_ip(addr) then
		isDomain = nslookup(addr)
		if is_valid_ip(isDomain) then addr = isDomain
	end if
	if not isDomain and not is_valid_ip(addr) then return print(warning+" not a valid IP")

	addr_label = "HIDDEN"
	if globals.anonymous == false then addr_label = addr
	print(init+"Net Session: searching: "+addr_label)
	router = null;ports = null;isLanIp = is_lan_ip(addr);fwd_machines = [];closed_machines = [];
	if isLanIp then 
		print("lan detected")
		router = get_router;
		if not router then return print(error+" An error occured")
		ports = router.device_ports(addr) // these appear to be forwarded ports ?
	else 
		router = get_router(addr); 
		if not router then return print(error+" An error occured")
		ports = router.used_ports
	end if
	devices = router.devices_lan_ip 	// any machine on the network reachable by ping on this address 
	//optional router attack
	if not ports or ports.len == 0 then 
		input = user_input(title+color.orange+"[Alert] No forward ports found\n"+color.yellow+"[SELECT]\n1.) Exploit the router \n0.) Exit\n--> ")
		if input.val == 1 then return Core.RouterEntry(addr, devices)
		if input.val != 1 then return print(title+" exiting . . .")
	end if 

	local_machines = devices // assign this list to a refernce of machine if we have 
	print(color.blue+"><> ><>"+color.cap+color.grey+" Machines reachable by ping: "+color.cap+"[ <b>"+color.white+devices.len+color.cap+"</B> ]"+color.blue+" ><> ")
	print(color.blue+color.fill); print(color.blue+"><> ><>"+color.cap+color.grey+" Machines with fowarded ports"+color.cap+color.blue+" ><> ><>")
	choices = color.orange+"0.) Attack_Router"; num = 1;info = null;
	for port in ports
		service = router.port_info(port)
		if not service then continue
		service_parsed = service.split(" ")
		service_lib = service_parsed[0]
		service_version = service_parsed[1]
		status = color.green+"open"+color.cap
		lan = port.get_lan_ip
		number = port.port_number
		if (port.is_closed and not isLanIp) then 
			status = color.red+"closed"+color.cap
			closed_machines.push(lan)
		else  
			// insert into list of processes to exploit
			fwd_machines.push([lan, number])
			choices = choices + "\n"+color.cyan + num+".) "+color.cap+color.purple+ lan +color.cap+color.white+ " " + number +color.cap+color.green +" " + service_lib
			num = num+1	
		end if
		info = info + color.cyan+service_lib+color.cap + " " + status + " " +color.grey+service_version+color.cap + " " + color.purple+lan+color.cap+color.white+" "+number+"\n"
	end for
	if fwd_machines.len == 0 then 
		input = user_input(title+color.orange+"[Alert] No open ports found\n"+color.yellow+"[SELECT]\n1.) Exploit the router \n0.) Exit\n--> ")
		if input.val == 1 then return Core.RouterEntry(addr, devices)
		if input.val != 1 then return print(title+" exiting . . .")
	end if 
	print(color.blue+"><>"+color.cap+" "+addr_label+color.cap+"::"+color.grey+number+color.cap+" Router: <b>v"+color.white+router.kernel_version)
	if globals.anonymous == false then Utils.who(addr)
	print(color.green+"><> "+color.cap+format_columns("LIB STATE VERSION LAN PORT")+color.green+" ><>")
	print(format_columns(info))
	print(color.blue+color.fill); print(format_columns(choices)); print(color.blue+color.fill)
	response = user_input(title+color.green+"-- "+color.white+"Select Entry"+color.cap+color.grey+" * Enter to Return *"+color.cap+color.green+" --> "+color.cap+color.white)
	if response.len == 0 then return	
	response = response.val
	lan = fwd_machines[response - 1][0]
	port = fwd_machines[response - 1][1]
	attack_choice = user_input(color.white+"--> "+color.cap)
	if attack_choice == "+" then 
		return Core.Inject_w_Save(addr, port)
	else if response == 0 then 
		return Core.RouterEntry(addr, devices)
	else 
		return Core.NetEntry(addr, lan, port)
	end if
end function
///============================
///============================ ROUTER ENTRY =====================///
///============================
Core.RouterEntry = function(addr, devices)
	// begin a task to begin a net session hack
	addr_label = "HIDDEN"
	if globals.anonymous == false then addr_label = addr
	hacked_object = null
	print(init+" Beginning Router Entry @ "+addr_label)
	if devices.len == 0 then return print(warning+" no devices found")
	options = "[ Computers ]"; count = 1; 
	for device in devices 
		options = options+"\n"+count+".) "+color.white+device
		count = count+1
	end for
	options = options + "\n0.)"+color.purple+" Net Router Entry\n"+color.yellow+"LAN"+color.cap+" Bounce Other Machine\n|| Return to Main\n"+color.green+"[Select] --> "+color.cap
	choice = user_input(options)
	inject = user_input("Press * to inject --> ")
	if choice == "||" then return print("Returning . . .")	
	if is_lan_ip(choice) then
		if inject == "*" then return Core.Inject_w_Save(addr, "0", choice)
		hacked_object = auto_hack(addr, 0, choice)
	else 
		choice = choice.val
		if choice == 0 then 
			if inject == "*" then return Core.Inject_w_Save(addr, "0")
			hacked_object = auto_hack(addr, 0)
		else
			if inject == "*" then return Core.Inject_w_Save(addr, "0", devices[choice-1])
			hacked_object = auto_hack(addr, 0, devices[choice-1])
		end if
	end if
	return hacked_object
end function
///============================
///============================ NET ENTRY =====================///
///============================
Core.NetEntry = function(ip, lan, port)
	ip_label = "HIDDEN"
	if globals.anonymous == false then ip_label = ip
	print(init+color.white+" Beginning Net Entry!"+color.cap+" --> "+color.grey+ip_label+color.cap+"/"+color.purple+lan+color.cap+":"+color.blue+port)
	hacked = null
	//obj = Utils.handle(object)
	if not is_valid_ip(ip) then return print(warning+ "invalid IP")
	hacked = auto_hack(ip, port)
	if globals.debug then print("we are expecting hacked_object to be map and its a : "+ typeof(hacked))
	if globals.debug then print("isa map "+(hacked isa map))
	if globals.debug then print("isa ShellObject "+(hacked isa ShellObject))
	if globals.debug then print("isa ComputerObject "+(hacked isa CompObject))
	if globals.debug then print("isa FileObject "+(hacked isa FileObject))
	if typeof(hacked) != "map" then 
	//if not hacked isa map then 
		print(warning+" "+color.white+ip_label+color.cap+" @ "+color.grey+lan+color.cap+" : "+color.orange+port+color.red+" Net Session FAILED" )
		if globals.debug then print(color.yellow+"debug: obj is of type: "+typeof(hacked)+":"+(hacked isa map))
		input = user_input("1.) Router Attack\n2.) New Net Attack \n3.) Bounce\n4.) Exit \nSELECT ->  ")
		input = input.val
		if input == 1 then
			hacked = auto_hack(ip, 0)
			if not hacked then return print(warning+ip_label+" couldnt be penetrated via router")
		end if
		if input == 2 then
			run = Core["Probe"] 
			return run(Current_Object, ip)
		end if
		if input == 3 then 
			value = user_input(color.yellow+"Enter a LAN: \n-->") 
			hacked = auto_hack(ip, 0, value)
		end if
		if input == 4 then 
			return hacked
		end if
	end if
	print("exiting net entry . . .")
	if globals.debug then print("we are expecting hacked_object to be map and its a : "+ typeof(hacked))
	return hacked
end function
///============================
///============================ DICTIONARY =====================///
///============================
// data:
// 
Core.Inject = function(entry, port, data = null, apt = null)
	print(init+"injecting . . .")
	if globals.Mode then return print(warning+"program is operating cfg: <b>"+color.white+globals.Mode)
	//if apt then result = get_local_hacks(true)
	//if not apt and port != 0 then result = get_remote_hacks(entry, port)
	//if port == 0 then result = get_remote_hacks(entry)
	if globals.debug then print(entry+" "+port)
	if not is_valid_ip(entry) then return print(warning+"invalid ip specified")
	if not port then return print(warning+"invalid port specified")
	if typeof(port) != "number" then port = port.to_int
	netsession = meta.net_use(entry, port)
	if not netsession then return print(error+"cannot establish net session")
	dump = netsession.dump_lib
	if not dump then return print(error+"failed to dump contents")
	lib = dump.lib_name
	libV = dump.version
	libName = lib+"_v"+libV
	query = Core.exp.search2(lib, libV)
	if not query then return print(warning+"invalid query")
	if query.len < 1 then return print(warning+"invalid db data")
	hacks = Core.exp.get_format(query)	
	types = ["shell", "computer","file","string","number",]
	if not data then data = "pass"
	for hack in hacks
		result = null
		if hack.len < 2 then continue
		result = dump.overflow(hack[1]["memory"], hack[2]["string"], data)
		type = typeof(result)
		if result == null then
			str = color.white+"overflow result --> "+color.cap+color.red+"FAIL"
			if hack.len > 3 then str = str+"\n"+color.grey+"><> ><> ><>\n"+hack[3]["requirements"]+"\n"+color.grey+"><> ><> ><>"
			print(str)
			continue
		end if
		print(color.white+"<i>overflow resulted in: </i><b>"+color.cap+color.green+type)
		a = null
		if type == "shell" then
			a = new ShellObject
			a.init(result);Core.add(a)
		else if type == "computer" then 
			a = new CompObject
			a.init(result);Core.add(a)
		else if type == "file" then 
			a = new FileObject
			a.init(result);Core.add(a)
		else if type == "string" then 
			continue
		else if type == "number" then
			Others.push(1)
			continue 
		end if
	end for

end function
// force - allow to save the exploits automatically for mass crack'n
Core.Inject_w_Save = function(entry, port, data = null, force = null)
	print(init+"injecting . . .")
	if globals.Mode then return print(warning+"program is operating cfg: <b>"+color.white+globals.Mode)
	if globals.debug then print(entry+" "+port)
	if not is_valid_ip(entry) then return print(warning+"invalid ip specified")
	if not port then return print(warning+"invalid port specified")
	if typeof(port) != "number" then port = port.to_int
	netsession = meta.net_use(entry, port)
	if not netsession then return print(error+"cannot establish net session")
	dump = netsession.dump_lib
	if not dump then return print(error+"failed to dump contents")
	lib = dump.lib_name
	libV = dump.version
	libName = lib+"_v"+libV
	query = Core.exp.search2(lib, libV)
	hacks = []
	if not query then 
		choice = 1
		if not force then choice = user_input(warning+"<i>Library not found, press 1 to manually scan & save\n--> ").to_int
		res = null
		if choice == 1 then 
			res = Tuxploit.scan(dump) 
		else 
			return print(warning+"invalid query")
		end if
		query = Core.exp.search2(lib, libV)
	end if
	if not query then return print(error+"invalid query")
	if query.len < 1 then return print(warning+"invalid db data")	
	hacks = Core.exp.get_format(query)	
	types = ["shell", "computer","file","string","number",]
	if not data then data = "pass"
	for hack in hacks
		result = null
		if hack.len < 2 then continue
		result = dump.overflow(hack[1]["memory"], hack[2]["string"], data)
		type = typeof(result)
		if result == null then
			str = color.white+"overflow result --> "+color.cap+color.red+"FAIL"
			if hack.len > 3 then str = str+"\n"+color.grey+"><> ><> ><>\n"+hack[3]["requirements"]+"\n"+color.grey+"><> ><> ><>"
			print(str)
			continue
		end if
		print(color.white+"<i>overflow resulted in: </i><b>"+color.cap+color.green+type)
		a = null
		if type == "shell" then
			a = new ShellObject
			a.init(result);Core.add(a)
		else if type == "computer" then 
			a = new CompObject
			a.init(result);Core.add(a)
		else if type == "file" then 
			a = new FileObject
			a.init(result);Core.add(a)
		else if type == "string" then 
			continue
		else if type == "number" then
			Others.push(1)
			continue 
		end if
	end for

end function

// EXPLOITS
// 1. checkLib
// 1. search
// 2. create
// 3. update

Core.exp = {}
///============================
///============================ LOAD DICT =====================///
Core.load_exploits = function()
	o = null
	if globals.DB1 then 
		return globals.DB1
	else if data then 
		if data.DB1 then o = data.DB1
	else 
		return null
	end if
	return o
end function
///============================
///============================ LOAD HASHES =====================///
Core.load_rainbow = function()
	o = null
	if globals.DB2 then
		return globals.DB2
	else if data then 
		if data.DB1 then o = data.DB2
	else 
		return null
	end if
	return o
end function
///============================
///============================ RAINBOW ROAD =====================///
///============================

arr = [color.red+"R"+color.cap,color.orange+"A"+color.cap,color.yellow+"I"+color.cap,color.green+"N"+color.cap, color.cyan+"B"+color.cap, color.blue+"O"+color.cap, color.purple+"W"+color.cap]
rCount = 0
Core.rainbow_road = function(rHash, cute = null)
	//if typeof(object) == "shell" and typeof(object) == "ftpshell" then return print(warning+"can only go down rainbow road on a shell")
	hasHash = null 
	db_folder = Core.load_rainbow
	if not db_folder then return print(error+"no exploit folder found") 
	for files in db_folder.get_files
		for each in files.get_content.split("\n")//.split(":")
			if each.split(":") == null or each.split(":").len == 1 then continue
			if each.split(":")[1] == rHash then hasHash = each.split(":")[0]
			if hasHash then break	
		end for
	end for
	if not hasHash and (Hashes.indexOf(rHash) == null) then 
		hasHash = Utils.cipher(null, rHash)
		label = null
		label = hasHash+":"+rHash
		Hashes.push(rHash)
		Cracked.push(label)
	end if
	print(color.rainbow+" "+hasHash)
	return hasHash
end function
///============================
///============================ FORMAT FROM DICT =====================///
Core.exp["get_format"] = function(data)
	hacks = []
	for parse in data.split("\n")
		values = []
		for s in parse.split(":::")
			pair = {}
			if s.split("::")[0] == "requirements" then 				
				pair["requirements"] = s.split("::")[1].replace(":", char(10))
			else if s.split("::")[0] == "exploit" then
				pair["exploit"] = s.split("::")[1]
			else if s.split("::")[0] == "memory" then
				pair["memory"] = s.split("::")[1]
			else if s.split("::")[0] == "string" then			
				pair["string"] = s.split("::")[1]
			else
				continue
			end if
			values = values + [pair]
		end for
		hacks = hacks+[values]
	end for
	return hacks
end function
data.get_format = @Core.exp.get_format
///============================
///============================ FORMAT TO DICT =====================///
Core.exp["set_format"] = function(data)
// take raw data from gethacks, and format it into parsable txt

end function
///============================
///============================ BROWSE DICT =====================///
Core["browse_exploits"] = function(object, library, libVersion)
	object  = Utils.handle(object)
	if typeof(object) == "shell" or typeof(object) =="ftpshell" then object = object.host_computer
	db_home = object.File("/home/"+Utils.user(object)+"/dict/exploits")
	if not db_home then db_home = globals.DB1
	if (db_home == null) and (data and data.DB1) then db_home = data.DB1
	if not db_home then 
		return print(error+"db main not found")
	end if
	db_sub = object.File("/home/"+Utils.user(object)+"/dict/exploits/"+library)
	if not db_sub then return print(error+"db sub not found")

	if libVersion == "-d" then
		// dump all content
		for file in db_sub.get_files
			print color.blue+color.fill
			print(color.green+"<b>"+file.name)
			hacks = Core.exp.get_format(file.get_content)
			for exploit in hacks
				if exploit.len == 0 then continue
				print color.blue+color.fill
				type = color.white+exploit[0]["exploit"]+color.cap
				memory = color.white+exploit[1]["memory"]+color.cap
				value = color.white+exploit[2]["string"]+color.cap
				print "Exploit: "+type+"\nAddress: "+memory+"\nValue: "+value
				if exploit.len > 3 then 
					print(color.grey+"><> ><> ><>\n"+color.yellow+"Requirements:"+color.cap+char(10)+exploit[3]["requirements"]+char(10)+color.grey+"><> ><> ><>")
				end if
			end for
		end for
	else if libVersion == "-l" then
		for file in db_sub.get_files
			print(color.white+file.name)
		end for
	else 
		db_file = object.File("/home/"+Utils.user(object)+"/dict/exploits/"+library+"/"+library+".so_v"+libVersion+".db")
		if not db_file then return print(warning+"db file not found")
		data = db_file.get_content
		hacks = Core.exp.get_format(data)
		print color.blue+color.fill
		print(color.green+"<b>"+db_file.name)
		for exploit in hacks
			if exploit.len == 0 then continue
			print color.blue+color.fill
			type = color.white+exploit[0]["exploit"]+color.cap
			memory = color.white+exploit[1]["memory"]+color.cap
			value = color.white+exploit[2]["string"]+color.cap
			print "Exploit: "+type+"\nAddress: "+memory+"\nValue: "+value
			if exploit.len > 3 then 
				print(color.grey+"><> ><> ><>\n"+color.yellow+"Requirements:"+color.cap+char(10)+exploit[3]["requirements"]+char(10)+color.grey+"><> ><> ><>")
			end if
		end for

	end if	
end function
///============================
///============================ SEARCH EXTENSIVE =====================///

Core.exp["search2"] = function(library, libVersion)
	if not library or not libVersion then return print(warning+"search: invalid args provided")
	print(init+color.grey+"<i>searching db for "+library+" "+libVersion)
	exploits = null
	db_folder = data.DB1
	if not db_folder then return print(error+"no exploit folder found") 
	for folder in db_folder.get_folders
		if (folder.name != library.split(".")[0]) and (library != "kernel_router" and (folder.name != "kernelrouter" and folder.name != "kernelrouter1")) then continue
		for file in folder.get_files
			if file.name == (library+"_v"+libVersion+".db") then
			exploits = file.get_content
			break 
			end if
		end for
	end for
	if not exploits then return print(warning+"<i>failed to load requested vulnerabilities file")
	print(title+color.green+"<i>loading vulnerabilities from</i> "+color.cap+color.red+library+"_v"+libVersion)
	return exploits
end function

data.query = @Core.exp.search2 // exportable query
Core.exp["create"] = function(object, library, libVersion, data)
	exploits = null
	valid_path = null

	// check base shell dir
	if not db_folder then return print(error+"no exploit folder found") 
	for folder in db_folder.get_folders
		if (folder.name != library.split(".")[0]) and (library != "kernel_router" and (folder.name != "kernelrouter" and folder.name != "kernelrouter1")) then continue
		valid_path = folder.path
	end for
	//depot = base.host_computer.File("/home/"+user+"/src/dict/exploits")
	if not valid_path then return print(error+" no exploit folder found") 
	exploit_file = base.host_computer.File(valid_path+"/"+library+"_v"+libVersion)
	formatted = @Core.exp["set_format"]
	content = formatted(data)
	
	if exploit_file == null then
		if globals.debug then print("exp: create c1")  
		create = base.host_computer.touch("/home/"+user+"/dict/exploits/"+library, library+"_v"+libVersion+".db")
		if typeof(create) != "string" then
			edit = exploit_file.set_content(content)
			if typeof(edit) == "string" then return print(warning+"failed to set file content")
			if edit == 1 then return print(color.green+" Exploit Save --> <b>OK</b>"+color.cap+" Library: "+color.white+library) 
		end if
		return print(create)
	end if
	print(library+"_v"+libVersion+" already exists")
end function
///============================
///============================ MASS LOOP =====================///
///============================
///============================
///============================ SAVE DATA =====================///
Core.exp["save_data"] = function(obj, data)
	print(init+"attempting to save results:")
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	l = obj.File("/home/2NA/dict/dump").get_files.len
	file = obj.touch("/home/2NA/dict/dump", "data"+str(l))
	if file != 1 then return print(warning+color.grey+"<i>failed to save file")
	lines = ""
	for d in data
		lines = lines + d + char(10)
	end for
	save = obj.File("/home/2NA/dict/dump/data"+str(l)).set_content(lines)
	if save == 1 then return print(color.white+"/home/2NA/dict/dump/data"+str(l)+" was saved successfully")
end function
///============================
///============================ SAVE RAINBOW =====================///
Core.exp["save_rainbow"] = function(obj)
	if globals.Cracked.len == 0 then return
	print(init+"updating --> "+color.rainbow)
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	l = obj.File("/home/2NA/dict/data/rainbow").get_files.len
	file = obj.touch("/home/2NA/dict/data/rainbow/", "r"+str(l))
	if file != 1 then return print(warning+color.grey+"<i>failed to create rainbow file")
	lines = ""
	for d in globals.Cracked
		lines = lines + d + char(10)
	end for
	save = obj.File("/home/2NA/dict/data/rainbow/r"+str(l)).set_content(lines)
	globals.Cracked = []
	if save == 1 then return print(color.white+"/home/2NA/dict/data/rainbow/r"+str(l)+" was saved successfully")
	print(warning+"failed to save rainbow file")
end function
//*obj: ShellObject
//*action: string [-r: router entry, -f:fwd port entry]
//*recon: string [ pw: etc only, -b: bank only, -m: mail only]| null: all hashes
//*offense: string [ BAM: name ] | null

Core.exp["mass_loop"] = function(obj, action, recon = null, offense = null)
	amount = user_input(title+"How far should we sail? --> ").to_int
	if amount < 0 or amount > 500 then amount = 250 end if
	start = time
	reconType = [ {"pw": "/etc/passwd"}, {"-b": "/Bank.txt"}, {"-m": "/Mail.txt"} ] 
	obj = Utils.handle(obj);
	completed_networks = [] // amount of networks we have crawled
	completed_tasks_label = [] // amount of machines we have crawled
	completed_tasks = [] // individual amount of tasks we performed
	binaries_launched = [] // amount of machines we launched binaries on 
	failed_machines = [] // amount of machines we failes
	interesting_machines = [] // machines worth revisitng
	scanning = true
	depot_folder = obj.host_computer.File("/root")
	if Utils.user(obj) != "root" then depot_folder = obj.host_computer.File("/home/"+Utils.user(obj))
	while scanning == true
		if scanning == false then break
		// random ip 
		public = Utils.random_ip
		router = get_router(public)
		if not router then continue
		print init+"\nscanning: "+color.white+public+"\ncaptured networks: [ "+color.white+completed_networks.len+color.cap+" ]\ncaptured machines: [ "+color.white+completed_tasks_label.len+color.cap+" ]\ncaptured objects:  [ "+color.white+completed_tasks.len+color.cap+" ]\n",1
		wait(1.8)
		ports = router.used_ports
		devices = router.devices_lan_ip			
		tasks = []
		if not ports or ports.len == 0 or action == "-r" then 
			// enter via router
			Core.Inject(public, "0", "pass")
		else 			
			// enter via open ports 
			for port in ports
				lan = port.get_lan_ip
				number = port.port_number
				//if completed_tasks.indexOf(public+":"+s.local_ip+":"+s.user+":"+typeof(s)) then continue
				//if taks.indexOf(lan) == null then tasks.push(lan)
				// fwd port attack
				Core.Inject_w_Save(public, str(number), "pass", true)
			end for
			// bounce?
		end if
		for device in devices
			Core.Inject_w_Save(public, "0", device, true)
		end for
		if globals.Shells.len == 1 and globals.Computers.len == 1 and globals.Files.len == 1 then continue
		// sort the objects gathered
		objects = [globals.Shells, globals.Computers, globals.Files]
		// begin to use said objects
		
		// tasks: 1.) get root, 
		
		for o in objects
			for obj_ in o
				task_notes = [] // keep track of some results ig
				if obj_[1] == "MAIN" then continue				
				if (obj_[0] isa FileObject) == false then 
					u = obj_[0].user
					b = obj_[0].bank
					m = obj_[0].email
					h = obj_[0].pass
					r = obj_[0].risk
					if u == "root" and (self.pass != "!/etc" and self.pass!="!r/etc" and self.pass!="!/passwd_content") then h = h.split("/n")[0].split(":")[0]+":"+Core.rainbow_road(h.split("/n")[0].split(":")[1])
					if b != "void" then
						b_mut = b.split(":")[0]
						b = b_mut+":"+Core.rainbow_road(b.split(":")[1])
					end if
					if m != "null" then 
						m_mut = m.split(":")[0]
						m = m_mut+":"+Core.rainbow_road(m.split(":")[1])
					end if
				else
						par = obj_[0].F.parent
						if not par then par = "/"
						n = obj_[0].F.name
						p = obj_[0].F.path
						o = obj_[0].F.owner
						r = obj_[0].F.has_permission("r")
						w = obj_[0].F.has_permission("w")	
						x = obj_[0].F.has_permission("x")
						s = obj_[0].scope
						c = ""
						etc = "!/etc"
						pw = "!/pw"
						if completed_tasks.indexOf(typeof(obj_[0].F)+"::"+n+"::"+s+"::"+p+"::"+c+"::"+public+"::"+o+"::*"+c) then continue
						if r == false then
							completed_tasks.push(typeof(obj_[0].F)+"::"+n+"::"+s+"::"+p+"::"+public+"::"+o+"::*!/r")
							continue
						end if
						if obj_[0].F.is_folder then 
							batch = obj_[0].F.get_files+ obj_[0].F.get_folders
							for b in batch 
								if obj_[0].F == "etc" and b.name == "passwd" then 
									c = c+b.get_content.replace("\n", "&")
									break
								else if obj_[0].F == "root" or obj_[0].F  == "home" then 
									for dir in par.get_folders
										if dir.name == "etc" then 
											for fi in dir.get_files
												if fi.name == "passwd" and fi.has_permission("r") then 
													c = c+fi.get_content.replace("\n", "&")
													break
												end if
											end for
										end if	
									end for
								end if
							end for
						end if
						completed_tasks.push(typeof(obj_[0].F)+"::"+n+"::"+s+"::"+p+"::"+c+"::"+public+"::"+o+"::*"+c)
					continue
				end if
				s = Utils.handle(obj_[0])
				s_mut = null
				if typeof(s) == "shell" or typeof(s) == "ftpshell" then 
					s_mut = s.host_computer
				else 
					s_mut = s // mutate it so we can keep the original
				end if
				// if we hacked this machine we skip
				if completed_tasks_label.indexOf(public+"::"+s_mut.local_ip) == null then completed_tasks_label.push(public+"::"+s_mut.local_ip)
				if completed_tasks.indexOf(typeof(s)+"::"+u+"::"+b+"::"+m+"::"+public+"::"+s_mut.local_ip+"::"+h) then continue
				// add the notes etc
				if BAM.isValid(offense) and typeof(s_mut) == "shell" then 
					// launch the specified binary
					BAM.handle(s, s.home, offense)
					binaries_launched.push(public+":"+s.local_ip+":"+u+":"+offense)
				end if
				//print("CAPTURED: "+typeof(s)+"::"+u+"::"+b+"::"+m+"::"+public+"::"+s_mut.local_ip+"::"+h)
				completed_tasks.push(typeof(s)+"::"+u+"::"+b+"::"+m+"::"+public+"::"+s_mut.local_ip+"::"+h)
			end for
		end for
		// SAVE
		// clear global object
		globals.Shells = [ [base_shell, "MAIN"] ] // our collection of global shell objects
		globals.Computers = [ [base_pc, "MAIN"] ] // our collection of global computer objects
		globals.Files = [ [base_file, "MAIN"] ] // our collection of global file objects
		completed_networks.push(public)
		if completed_networks.len == amount then scanning = false
	end while
	completion = time
	res = str(completion - start)
	print(init+"RESULT:\ncaptured networks: [ "+color.white+completed_networks.len+color.cap+" ]\ncaptured machines: [ "+color.white+completed_tasks_label.len+color.cap+" ]\ncaptured objects:  [ "+color.white+completed_tasks.len+color.cap+" ]\nElapsed:"+res+"\n", 1)
	wait(1.5)
	Core.exp.save_rainbow(obj)
	return Core.exp.save_data(obj, completed_tasks)
end function
Tuxploit={"exploits":[]}
Tuxploit.get=function(m)
	if not m.lib_name then return null
	c=null
	p=null
	n=m.lib_name+"_v"+m.version+".db"
	x=m.lib_name.replace("_","").split(".").pull
	c = globals.Shells[0][0].shell.host_computer
	p = data.DB1.path
	
	l=c.File(p+"/"+x+"/"+n)
	if l then return l
	l=c.File(p+"/"+x+"1"+"/"+n)
	if l then return l
	if c.File(p+"/"+x) then
		r=c.touch(p+"/"+x,n)
		if r isa string then
			c.create_folder(p,(x+"1"))
			c.touch(p+"/"+(x+"1"),n)
			return c.File(p+"/"+(x+"1")+"/"+n)
		else
			return c.File(p+"/"+x+"/"+n)
		end if
	else
		c.create_folder(p,x)
		c.touch(p+"/"+x,n)
		return c.File(p+"/"+x+"/"+n)
	end if
end function
Tuxploit.write=function(z,m)
	if self.exploits then self.exploits=[]
	f=self.get(m)
	if not f then return print(error+"File IO","Write Exploits")
  	s=[]
	for e in z
		c=e.indexes.len
		for k in e.indexes
			c=c-1
			if not c then s.push k+"::"+e[k] else s.push k+"::"+e[k]+":::"
		end for
		s.push NL
	end for
	test = f.set_content(s.join(""))
	return test
end function
Tuxploit.load=function(m)
	v=[]
	a=self.get(m)
	if not a then return v
	for i in a.get_content.split(NL)
		if not i.len then continue
		k={}
		j=i.split(":::")
		if not j.len then continue
		for e in j
			if not e.len then continue
			e=e.split("::")
			A=e.pull
			B=e.pull
			if A=="exploit" then
				k["exploit"]=B
				continue
			end if
			if A=="memory" then
				k["memory"]=B
				continue
			end if
			if A=="string" then
				k["string"]=B
				continue
			end if
			if A=="user" then
				k["user"]=B
				continue
			end if
			if A=="parameters" then
				k["parameters"]=B
				continue
			end if
			if A=="requirements" then
				k["requirements"]=B
				continue
			end if
		end for
		if k then v.push k
	end for
	return v
end function
Tuxploit.scan=function(t)
	_r=function(z)
		a=-1
		for e in z
			a=a+1
			b=z.len-1
			while b>a
				if e.memory==z[b].memory and e.string==z[b].string then z.remove(b)
				b=b-1
			end while
		end for
		return z
	end function
	q=[]
	x=null
	r=null
	for a in meta.scan(t)
		for l in meta.scan_address(t,a).split(NL)
			if not l.len then continue
			if l.indexOf("Unsafe check")==0 then
				if x then
					if r then x["requirements"]=r
					q.push x
				end if
				s=l.indexOf("<b>")+3
				d=l.indexOf("</b>")
				x={"exploit":"Unknown","string":l[s:d],"memory":a,"user":""}
				r=null
				continue
			end if
			if l[0]=="*" then
				if r then r=r+":"+l else r=l
			end if
		end for
	end for
	if x then
		if r then x["requirements"]=r
		q.push x
	end if
	c=[]
	h=self.get(t)
	if not h then return c
	for e in q
		if t.lib_name=="kernel_router.so" then e.exploit="Router"
		c.push "exploit::"+e.exploit+":::"
		c.push "memory::"+e.memory+":::"
		c.push "string::"+e.string+":::"
		c.push "user::"+"Unknown"
		if e.hasIndex("requirements") then c.push ":::requirements::"+e.requirements
		c.push NL
	end for
	h.set_content(h.get_content+c.join(""))
	return self.write(_r(self.load(t)),t)
end function
//////////////////////////////////////////////////////////////  
///======================= CORE =========================////
////////////////////////////////////////////////////////////

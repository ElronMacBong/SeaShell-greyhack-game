if not globals.entry_core then exit("><> ><> ><>")
//////////////////////////////////////////////////////////////  
///======================= CORE =========================////
////////////////////////////////////////////////////////////
Core = {}
CMD = {}
///======================= CMD isValid =========================////
Core.isValid = function(param)
	pos = 0
	for p in Core.list
		pos = pos+1
		if p["name"] == param then return p
		if p["name"] == "--" and (is_valid_ip(param) or is_valid_ip(nslookup(param))) then 
			if globals.debug then print(color.green+"FOUND COMMAND: "+ p["name"])
			return p
		end if
	end for
	return null
end function
// format command
fcmd = function(string)
	if string.indexOf("|") == null then return print("not a parsable command") 
	rep = string.replace("|", " ")
	parse = rep.split(" ")
	return parse
end function
///======================= CMD hasRequiredArgs =========================////
Core.hasRequiredArgs = function(cmd, p)
	if globals.debug then print(color.red+"CMD: "+cmd["name"])
	if globals.debug then print(color.yellow+"REQUIRED: "+cmd["params"].len)
	if globals.debug then print(color.orange+"PASSED ARGS: "+color.cap+color.grey+p)
	passed = 0
	for cmdIndex in cmd["params"]
		if cmdIndex == "*" then
			if globals.debug then print("args: c1") 
			passed = passed+1
			continue
		end if
		if globals.debug then print(color.purple+"POSSIBLE ARG: "+cmdIndex)
		if cmdIndex.indexOf("|") then
			if globals.debug then print("args: c2")
			parse = fcmd(cmdIndex)
			if globals.debug then print(parse)
			for parsed in parse
				if globals.debug then print("parsed: "+parsed)
				if globals.debug then print("p.indexOf(parsed): "+p.indexOf(parsed)+" TYPE: "+typeof(p.indexOf(parsed)))
				if globals.debug then print("cmdIndex == * "+(parsed == "*"))
				if typeof(p.indexOf(parsed)) == "number" or (parsed == "*") then 
					passed = passed+1
					break
				end if
			end for
		else 
			if globals.debug then print("args: c3")
			for argIndex in p
				if globals.debug then print(color.white+"argIndex: "+argIndex)
				if globals.debug then print("cmdIndex.indexOf(argIndex): "+cmdIndex.indexOf(argIndex)+" TYPE: "+typeof(cmdIndex.indexOf(argIndex)))
				if globals.debug then print("cmdIndex == * "+(cmdIndex == "*"))
				if typeof(p.indexOf(argIndex)) == "number" or (cmdIndex == "*") then 
					passed = passed+1
				end if
			end for
		end if
		
	end for
	if globals.debug then print("total: "+passed)
	if passed == cmd["params"].len then return true
	if globals.debug then print("c6")
	return null
end function

Core["cmd"] = function(object, params)
	error = null
	result = null
	cmd = params.split(" ")
	if globals.debug then print(color.white+"recieved cmd: <b>"+color.cap+color.grey+cmd)
	valid = Core.isValid(cmd[0])
	if not valid then return print(warning+color.yellow+"Invalid Command\n"+color.white+"Use command "+color.grey+"<b>-h</b>"+color.cap+color.white+" for list of valid commands")
	if globals.debug then print(color.green+"running CMD: <b>"+color.cap+color.white+valid["name"])
	run = valid["run"]
	if cmd.len == 1 then
		if globals.debug then print("cmd: c1")
		if valid["cb"] == "result" then
			if globals.debug then print("cmd: c1a")  
			if valid["name"] == "-g" then result = run
			if not valid["name"] == "-g" then result = run(object, cmd[0])
		else if valid["cb"] == "custom" then
			data = get_custom_object()
			data.so = @ShellObject
			data.root = null
			run(object, "-p")
			if data.root != null then result = data.root
		else if valid["cb"] == "Current_Path" then  
			Current_Path = run(object)
		else if valid["cb"] == "anon" then  
			anonymous == run
		else if valid["cb"] == "general" then 
			run
		else if valid["cb"] == "EXIT" then
			result = "EXIT" 
		else
			run(object)
		end if
	else if cmd.len > 1 then
		cmd.pull // remove the main param, and leave arguments
		if valid["params"].len < cmd.len then return print(warning+ "too many arguments")
		if globals.debug then print("cmd: c2") 
		args = Core.hasRequiredArgs(valid, cmd) 
		if args == null then return print("lacking required args c2")
		run = valid["run"]
		if cmd.len == 1 then
			if valid["cb"] == "result" then
				if globals.debug then print("cmd: c2a")
				result = run(object, cmd[0])
			else if valid["cb"] == "general" then
				run(cmd[0])
			else
				run(object, cmd[0])
			end if
		else if cmd.len == 2 then 
			// etc etc
			if valid["cb"] == "result" then
				result = run(object, cmd[0], cmd[1])
			else if valid["cb"] == "general" then
				run(cmd[0], cmd[1])
			else if valid["cb"] == "custom" then
				data = get_custom_object()
				data.so = @ShellObject
				data.root = null
				run(object, cmd[0], cmd[1])
				if data.root != null then result = data.root
			else
				run(object, cmd[0], cmd[1])
			end if
		else if cmd.len == 3 then
			// etc etc 
			if valid["cb"] == "general" then
			else
				// moments like this, i miss the spread operator 
				run(object, cmd[0], cmd[1], cmd[2])
			end if
		end if
	end if
	return result
end function


// object: ShellObject: Map | CompObject: Map | FileObject: Map
// global_path = out global path fool
///======================= PROMPT =========================////
Core.prompt = function(o, p, anonymous)
	user_color = color.white
	type = color.purple+"S"+color.cap 
	if (o isa ShellObject) == true then
		if typeof(o.shell) == "ftpshell" then type = color.yellow+"FTP"+color.cap
		o = o.shell.host_computer
	else if (o isa CompObject) == true then
		o = o.PC 
		type = color.blue+"C"+color.cap
	else if (o isa FileObject) == true then 
		type = color.green+"F"+color.cap
	else 
		return print(warning+ " Invalid prompt type")
	end if
	user = Utils.user(o)
	if user == "root" or user == "2NA" then user_color = color.green
	if user == "guest" then user_color = color.orange
	if user == "unknown" then user_color = color.red
		ip = o.public_ip;lan = o.local_ip
	if anonymous == true then ip = "HIDDEN"
	if anonymous == true then lan = "HIDDEN"
		spacing = 3.9
	pc = "fish"
	spacing = spacing+(user.len+pc.len)*0.6
	str =  "\n<pos=04>—{<b>"+user_color+user+color.cap+"</b>}—[<b>"+type+"</b>]—{"+color.white + ip + color.cap+":"+color.grey + lan + color.cap+"}—[<b>"+color.white+p+color.cap+"</b>]<voffset=-0.5em><space=-"+spacing+"em><pos=00>|<voffset=-1em><space=-0.6em>|<voffset=-1.5em><pos=04>——:~"+color.white+"$"+color.cap+" " 				
	response = user_input(str)
	return response
end function

///======================= CMD  LIST =========================////
Core["cmd_list"] = function(usage = null)
	p = null
	if not usage then
		tData = []
		tData.push({"<b><u>[ NAME ]": [0,0,0,0]})
		tData.push({"[ ARGS ]": [12,0,0,0]})
		tData.push({"[ DESC ]          /\n": [55,0,0,0]})
		for c in Core.list
			tData.push({color.white+c["name"]+color.cap: [1,0,0,0]})
			tData.push({c["params"]: [10,0,0,0]})
			tData.push({color.grey+c["desc"]+"\n": [45,0,0,0]})
		end for
			print GFX.f(tData)
		p = true
	else
		locals.i = null
		for item in Core.list
			if item["name"] == usage then 
				locals.i = item
				break
			end if
		end for
		if not locals.i or not locals.i["usage"] then return print(color.grey+"*<i>Usage not found</i>*"+color.cap+" cmd:<b> "+color.white+usage+color.cap)//+"</b> \n-->"+color.grey+"* Chec")
		print(color.purple+"CMD: "+color.cap+"<b>"+usage+"</b>\n"+color.green+"ARGS: "+color.cap+locals.i["params"]+"\n"+color.white+"USAGE:"+color.cap+"\n"+locals.i["usage"])
	end if
	print(color.white+"<b>-->"+color.cap+ " *</b><i>"+color.grey+" Represents a dynamic, or optional parameter.")
	if p then print("*"+color.grey+"<i>DETAILS</i>"+color.cap+"*  Use cmd: "+color.white+"<b>-h [cmd_name]</b>"+color.cap+" for CMD usage")
end function
///======================= ANON MODE =========================////
Core["anon"] = function()
	g = true
	if globals.anonymous == 1 then g = false
	globals.anonymous = g
	return globals.anonymous
end function
///======================= OBJECT POOL =========================////
Core["objects"] = function()
	objects = [globals.Shells, globals.Computers, globals.Files]
	if objects.len == 0 or objects[0].len == 0 or objects[1].len == 0 or objects[2].len == 0 then return print(warning+" no object options found")
	selected_obj = null
	selecting = true
	sm = 0 
	while selecting == true 
		if selecting == false then break
		c = 1 // count
		menu = [color.white+"~^~^~^~ <u>Main</u> ~^~^~^~"+color.cap, color.purple+"~^~^~^~ Shells ~^~^~^~"+color.cap, color.blue+"~^~^~^~ Computers ~^~^~^~"+color.cap, color.green+"~^~^~^~ Files ~^~^~^~"+color.cap, color.grey+"~^~^~^~ Other ~^~^~^~"+color.cap]
		if sm == 0 then 
			options = [color.purple+" Shells "+color.cap+"(<b>"+color.white+globals.Shells.len+color.cap+"</b>)", color.blue+" Computers "+color.cap+"(<b>"+color.white+globals.Computers.len+color.cap+"</b>)", color.green+" Files "+color.cap+"(<b>"+color.white+globals.Files.len+color.cap+"</b>)",]
		else 
			options = objects[sm-1]
		end if
		choices = menu[sm]
		for o in options
			info = ""
			if sm == 0 then
				info = info+o 
				in_main = true
			else if sm == 1 then 
				col = color.white
				u = Utils.user(o[0].shell)
				if @u == "root" then col = color.green
				if @u == "guest" then col = color.orange
				if @u == "unknown" then col = color.red
				i = o[0].pc.public_ip
				if globals.anonymous == true then i = "HIDDEN"
				info = "[ " +col+ u +color.cap+ " ]<s>   </s>{" +color.white+i+color.cap+":"+color.grey+o[0].pc.local_ip+color.cap+"}"
				in_main = false
			else if sm == 2 then		// computer exploit
				col = color.white
				u = Utils.user(o[0].PC)
				if @u == "root" then col = color.green
				if @u == "guest" then col = color.orange
				if @u == "unknown" then col = color.red
				i = o[0].PC.public_ip
				if globals.anonymous == true then i = "HIDDEN"
				info = " [ "+col+ u +color.cap+" ]<s>   </s>{" +color.white+i+color.cap+":"+color.grey+o[0].PC.local_ip+color.cap+"}"
				in_main = false
			else if sm == 3 then 
				lvl=""
				if o[0].F.has_permission("r") then lvl = lvl+"r"
				if o[0].F.has_permission("w") then lvl = lvl+"w"
				if o[0].F.has_permission("x") then lvl = lvl+"x"
				info = format_columns(o[0].F.name+" "+o[0].F.owner+" "+o[0].F.group+" "+lvl+" "+o[0].F.permissions)
				in_main = false
		end if
		// ;-;
			if sm == 0 then 
				choices = choices+"\n"+c+".)"+info
			else
				choices = choices+"\n"+c+".)"+info+" "+o[1]
			end if
			c = c+1
		end for
		
		if sm == 0 then 
			print(format_columns(choices))
		else 
			print(choices)
		end if
		choice_response = null
		if in_main == true or sm == 0  then 
			menu_response = user_input(color.green+"[ SELECT MENU ] "+color.cap+color.grey+"* exit to return*"+color.cap+color.white+" --> ")
			if menu_response == "exit" then 
				selecting = false
				return null
			end if
			sm = menu_response.val
		end if
		
		if sm == 0 and in_main == false then return
		if sm > 0 and in_main == false then 
			choice_response	= user_input(color.green+"[ CHOOSE OPTION ] "+color.cap+color.grey+"* Press 0 to return*"+color.cap+color.white+" --> ")
			if choice_response.val == 0 then 
				sm = 0
				continue
			end if 
			if choice_response.val > options.len then continue
			if choice_response.val == 0 then sm = 0

			attack_choice = user_input(color.orange+"[ CONFIRM ] \n"+color.white+"1.)"+color.cap+color.purple+" Surf Mode\n"+color.white+"2.)"+color.cap+color.red+" Remove Object\n"+color.white+"-- "+color.cap+color.grey+" * Press any to return *"+color.cap+color.white+" --> ")
			attack_choice = attack_choice.val
			if attack_choice == 1 then
				chosen_obj = options[choice_response.val-1] 
				selected_obj = chosen_obj[0]
				selecting = false
				return selected_obj
			else if attack_choice == 2 then 
				Core["remove(sm, choice_response)"]
			end if
		end if
	end while
end function
///======================= OBJ ADD =========================////
Core.add = function(object) // : map
	if (object isa ShellObject) == true then 
		globals.Shells = globals.Shells.push([object, "captured"])
	else if (object isa CompObject) == true then 
		globals.Computers = globals.Computers.push([object, "captured"])
	else if (object isa FileObject) == true then 
		globals.Files = globals.Files.push([object, "captured"])
	else 
		return print(warning+" unable to add object to the pool: "+typeof(object))
	end if
	Current_Object = object
end function
///======================= OBJ REMOVE  =========================////
Core.remove = function(type, index) // : number, : number
	t = "unknown"
	if type == 1 then 
		t = "shell"
		globals.Shells = globals.Shells.remove(index)
	else if type == 2 then
		t = "pc" 
		globals.Computers = globals.Computers.remove(index)
	else if type == 3 then 
		t = "file"
		globals.Files = globals.Files.remove(index)
	else 
		return print(warning+" unable to remove "+t+" object from the pool")
	end if
	
end function
///======================= cd  =========================////
Core["cd"] = function(obj, p)
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	base = null
	if not p then
		if Utils.user(obj) == "root" then globals.Current_Path = "/root"
		if Utils.user(obj) != "root" then globals.Current_Path = "/home/"+Utils.user(obj) 
		return globals.Current_Path
	else
		base = obj.File(globals.Current_Path)
		if not base then return print("cd: path not found")
	end if
	dir = null
	if p == "./" then 
		dir = base.parent
	else if p == "/" then 
		dir = obj.File("/")
	else if p != "/" and base.name == "/" then 
		dir = obj.File("/"+p)
	else if p[0] == "/" then
		dir = obj.File(p)
	else if p != null then
		dir = obj.File(base.path+"/"+p)
	end if

	if dir == null then return print("No directory found")
	globals.Current_Path = dir.path
	return globals.Current_Path
end function
///======================= me  =========================////
Core["me"] = function(obj)
	obj = Utils.handle(obj)
	return print(Utils.user(obj))
end function

///=====================================================////
////////////////////////// SHELL ///////////////////////
///====================================================////

// =======================  terminal =======================
Core["terminal"] = function(obj, _)
	obj = Utils.handle(obj)
	if typeof(obj) != "shell" and typeof(obj) != "ftpshell" then return print("-t cant launch")
	return obj.start_terminal
end function
// =======================  sudo =======================
Core["sudo"] = function(s = get_shell, arg, arg2=null, arg3=null)
	if typeof(s) == "map" then s = Utils.handle(s)
	computer = s.host_computer
	inputPass = user_input("Password: ", true)
	if arg == "-u" then s = get_shell(arg2, inputPass)
	if arg == "-s" or arg == "-l" then s = get_shell("root", inputPass)
	if not s then return print(color.orange+"AUTH FAIL")
	if arg == "-l" then 
		program = computer.File(arg2)
		if not program then return print(arg2 + " not found.")
		if not arg3 then s.launch(arg2)
		if arg3	then s.launch(arg2, arg3)
	end if
	so = null
	if typeof(s) == "shell" then 
		so = new ShellObject
		so.init(s)
	end if
	return so
end function
// =======================  launch =======================
Core[".exe"] = function(obj, p, data = null)
	obj = Utils.handle(obj)
	if typeof(obj) != "shell" and typeof(obj) != "ftpshell" then return print(color.yellow+"exe: cant launch")
	dirs = ["/home/guest", "/bin", "/home/guest/Desktop/.cache"]
	file = null
	if p == "-e" then 
		for file in dirs 
			f = obj.host_computer.File(file+"/eel")
			if f then 
				file = f
				break
			end if
		end for
		if typeof(file) == "file" then obj.launch(file.path, "-a")
	else if p == "-p" then 
		for file in dirs 
			f = obj.host_computer.File(file+"/payload")
			if f then 
				file = f
				break
			end if
		end for
		if typeof(file) == "file" then 
			if data then obj.launch(file.path, data)
			if not data then obj.launch(file.path)
		end if
	else if p == "-s" then 
		for file in dirs 
			f = obj.host_computer.File(file+"/ss")
			if f then
				print("found ss: "+f.path) 
				file = f
				break
			end if
		end for
		if typeof(file) == "file" then obj.launch(file.path, "-a")
	else 
		if p[0] != "/" and Current_Path != "/" then p = Current_Path+"/"+p
		if data then 
			obj.launch(p, data)
		else
			obj.launch(p)
		end if
		file = ";)"
	end if
	if file == null then print(warning+color.yellow+"<i>launch binary not found on target machine")
	return data
end function
// =======================  service =======================
Core["service"] = function(object, action, service = null, force = null)
	print(init+color.yellow+"Service Manager")
	obj = Utils.handle(object)
	ip = obj.host_computer.local_ip
	if action == "-l" then
		svs = ["libchat.so", "librepository.so", "librshell.so", "libsql.so","libhttp.so","libftp.so","libssh.so"]
		svs_dis = null
		height = 0
		for s in svs
			library = get_library(s)
			status = "----->"+color.red+" missing"+color.cap+color.grey+" X"
			if library then 
				running = null
				router = get_router
				ports = router.device_ports(ip)
				fwdPorts = router.used_ports
				fwd = color.grey+" UNKNOWN"
				for p in ports
					srv = router.port_info(p)
					if not srv then continue
					lan = p.get_lan_ip
					//if lan == ip then continue
					service_parsed = srv.split(" ")
					service_lib = service_parsed[0]
					if ("lib"+service_lib+".so" == s) and (lan == ip) then 
						fwd = color.green+" INTERNAL"
					end if
				end for
				for p in fwdPorts
					srv = router.port_info(p)
					if not srv then continue
					lan = p.get_lan_ip
					//if lan == ip then continue
					service_parsed = srv.split(" ")
					service_lib = service_parsed[0]
					if ("lib"+service_lib+".so" == s) and (lan == ip) then 
						fwd = color.red+" EXTERNAL"
					end if
				end for
				//print(format_columns(info))
				test = library.stop_service
				if test == 1 then 
					library.start_service
					running = true
				end if
				// if running then shrug
				if not running then 
					status = "----->"+color.yellow+" offline"+color.cap+fwd
				else 
					status = "----->"+color.green+" online"+color.cap+fwd
				end if
			end if
			svs_dis = color.white+s+color.cap+" "+status+"\n"+svs_dis
		end for
		return print(color.blue+color.fill+"\n"+format_columns(svs_dis))
	else if (action == "-s" or action == "-k") and (service == "libhttp.so") and (force != null) then
		run = Utils["webmanager"]
		run(obj, force)
	end if
	srv = null
	srv = get_library(service)
	if not srv then return print(warning+service+" not found")
	act = null
	locals.router = get_router
	if not router then return print(error+" An error occured")
	ports = router.device_ports(obj.host_computer.local_ip) // these appear to be forwarded ports ?
	act_label = "install"
	if action == "-i" and service then
		print(color.white+"installing: <i>"+service) 
		act = srv.install_service
	else if action == "-s" and service then
		print(color.white+"Starting: <i>"+service) 
		act = srv.start_service
		act_label = "start"
	else if action == "-k" and service then
		print(color.white+"Stopping: <i>"+service)
		act_label = "kill" 
		act = srv.stop_service
	end if
	if typeof(act) == "string" then 
		return print(warning+"<b>"+color.red+act)
	else if act == 1 then 
		print(act_label+" "+color.white+service+color.cap+" ---> "+color.green+"<b>OK")
	else 
		return print(warning+"failed to "+act_label+" "+service)
	end if
end function


///=====================================================////
////////////////////////// COMPUTER ///////////////////////
///====================================================////

// =======================  ps =======================
Core["ps"] = function(obj)
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	output = obj.show_procs
	return print(format_columns(output))
end function
// =======================  kill =======================
Core["kill"] = function(obj, pid)
	obj = Utils.handle(obj)
	pid = pid.to_int
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	if typeof(pid) != "number" then return print(warning+" The PID must be a number\n")
	output = obj.close_program(pid)
	if output == true then return print("Process " + pid + " closed");
	if output then return print(output)
	print("Process " + pid + " not found")
end function
// =======================  pw =======================
Core["pw"] = function(obj, user)
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	inputMsg = "Changing password for user " + user +".\nNew password:"
	inputPass = user_input(inputMsg, true)
	output = obj.change_password(user, inputPass)
	if output == true then return print(user+" password modified OK")
	if output then return print(output)
	print(warning+" password not modified, are you root?")
end function
// =======================  touch =======================
Core["touch"] = function(obj, pathFile, fileName)
	if globals.debug then print("path: "+ pathFile+"\nfileName: "+fileName)
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	if fileName == "" or fileName == null then 
		if globals.debug then print("tch: c1")
		destParent = Utils.pth(pathFile) // define destination
		destParse = destParent.split("/") // parse
		fileName = destParse[destParse.len-1] // get name
		pathFile = destParent.split(fileName)[0] // use name to get parent
	end if
	// single arg
	create = obj.touch(pathFile, fileName)
	file = obj.File(pathFile+"/"+fileName)
	if file == null then return print(warning+"touch: failed")
	print(color.white+fileName+color.cap+" created at path "+color.yellow+pathFile)
end function
// =======================  mkdir =======================
Core["mkdir"] = function(obj, pathFile, fileName)
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	if fileName == "" or fileName == null then 
		if globals.debug then print("mkdir: c1")
		destParent = Utils.pth(pathFile) // define destination
		destParse = destParent.split("/") // parse
		fileName = destParse[destParse.len-1] // get name
		pathFile = destParent.split(fileName)[0] // use name to get parent
	end if
	file = obj.create_folder(pathFile, fileName)
	if file == false then return print("mkdir: failed")
	print(fileName+" created at path "+ pathFile)
end function

// ======================= SCP =========================
Core["scp"] = function(remote, type, origPath, destPath=null)
	home_shell = null;remote_shell = null;
	home_shell = globals.Shells[0][0];
	home_shell = Utils.handle(home_shell);
	if not destPath then destPath = Current_Path
	if origPath[0] != "/" then origPath = Utils.pth(origPath)
	if typeof(home_shell) == "ftpshell" then return print(warning+"object is of type ftpshell")
	remote_shell = Utils.handle(remote)
	if type == "-d" then 
		remote_shell.scp(origPath, destPath, home_shell)
	else if type == "-u" then 
		home_shell.scp(origPath, destPath, remote_shell)
	else 
		return print("an error occured")
	end if
end function
///============================
// ======================= PUT =========================
///============================
Core["put"] = function(remote, origPath, destPath)
	if typoef(remote) != "ftpshell" then return print(warning+"object is not of type ftpshell")
	home_shell = null;
	remote_shell = null;
	home_shell = globals.Shells[0][0];
	home_shell = Utils.handle(home_shell);
	remote_shell = Utils.handle(remote)
	home_shell.put(origPath, destPath, remote_shell)
end function
///============================
// ======================= GET =========================
///============================
Core["get"] = function(remote, origPath, destPath)
	if typoef(remote) != "ftpshell" then return print(warning+"object is not of type ftpshell")
	home_shell = globals.Shells[0][0];
	home_shell = Utils.handle(home_shell);
	remote_shell = Utils.handle(remote)
	remote_shell.put(origPath, destPath, home_shell)
end function
// ======================= SSH =========================
Core["ssh"] = function(shell, connect_string, ip, port = 22)
	object = Utils.handle(shell)
	if typeof(object) != "shell" then return print(" no shell detected")
	connect_string = connect_string.split("@")
	service = object.connect_service(ip, port, connect_string[0], connect_string[1])
	so = null
	if typeof(service) == "shell" then
		Utils.paired_msg 
		so = new ShellObject
		so.init(service)
	end if 
	return so
end function
// ======================= FTP =========================
Core["ftp"] = function(object, connect_string, ip, port = 21)
	object = Utils.handle(object)
	if typeof(object) != "shell" or typeof(object) == "ftpshell" then return print(" no shell detected")
	if not object then object = Global_Shells[0][0]
	connect_string = connect_string.split("@")
	service = object.connect_service(ip, port, connect_string[0], connect_string[1], "ftp")
	so = null
	if typeof(service) == "ftpshell" then
		Utils.paired_msg 
		so = new ShellObject
		so.init(service)
	end if 
	return so
end function
// ======================= SECURE =========================
Core["secure"] = function(obj, type = "-h")
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	if Utils.user(obj) != "root" then return print("You need to be root to run this operation")
	root = obj.File("/")
	if not root then return print("no root?")
	chO = root.chmod("o-wrx", true);wait(0.1);
	if chO.len > 1 then print(warning+" failed to adjust scope Other to /\n"+chO)
	mail=null;bnk=null;
	if type == "-s" then
		chG = root.chmod("g-wrx", true).len
		chU = root.chmod("u-wrx", true).len
		if chG > 1 then print(warning+" failed to adjust scope Group to /\n"+chG)
		if chU > 1 then print(warning+" failed to adjust scope User to /\n"+chU)
		mail = obj.File("/root/Config/Mail.txt")
		bnk = obj.File("/root/Config/Bank.txt")
		if obj.File("/home") then obj.File("/home").delete
		
		
		
	else 
		cfg = obj.File("/home/2NA/Config")
		if cfg then
			ch = null 
			ch = cfg.set_owner("root", true).len;wait(0.1);
			if ch > 1 then print(ch)
			ch = cfg.set_group("root", true).len;wait(0.1);
			if ch > 1 then print(ch)
		end if
		wait(0.1)
		mail = obj.File("/home/2NA/Config/Mail.txt")
		bnk = obj.File("/home/2NA/Config/Bank.txt")
		if mail then mail.delete
		if bnk then bnk.delete
		files = ["/sys", "/boot", "/lib"]
		for file in files
			if obj.File(file) then obj.File(file).chmod("u-wx", true)
		end for
		
	end if
	if mail then
		print(color.yellow+"<b>Mail deleted!!") 
		mail.delete
	end if
	if bnk then
		print(color.yellow+"<b>Bank deleted!!")  
		bnk.delete
	end if
	wait(0.2)
	pw = obj.File("/etc/passwd")
	del = "o"
	if pw then del = pw.delete
	wait(0.1)
	if del.len > 1 then print("Deleted /etc/passwd")
end function

///=====================================================////
///////////////////////////// FILE /////////////////////////
///====================================================////

// =======================  ls =======================
Core["ls"] = function(obj)
	p = globals.Current_Path
	if not p then p = current_path
	print(init+"fs: "+color.yellow+p)
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then 
		folder = obj.host_computer.File(p)
	else if typeof(obj) == "computer" then 
		folder = obj.File(p)
	end if
	if folder == null then return print("ls no file or directory found")
	if not folder.has_permission("r") then return print("You do not have read access for "+folder)
	folder_path = p
	sub_files = folder.get_folders + folder.get_files
	output = ""
	if not sub_files then
		output = "*"+color.grey+"<i>This Directory Has No Content</i>"+color.cap+"*  Use cmd: "+color.white+"<b>cd ./</b>"+color.cap+" to navigate to previous directory"
	else if sub_files.len > 0 then 
		output = color.grey+"NAME"+color.cap+" "+color.white+"TYPE"+color.cap+" "+color.grey+"OWNER"+color.cap+" "+color.white+"GROUP"+color.cap+" "+color.grey+"SIZE"+color.cap+" "+color.white+"PERMISSIONS"+color.cap
	end if
	for f in sub_files
		if output.len > 0 then 
			output = output + "\n"
		end if
		file_type = color.cyan+"txt"+color.cap
		if f.is_folder then file_type = color.purple+"dir"+color.cap
		if f.is_binary and not f.is_folder then file_type = color.grey+"bin"+color.cap
		file_name = f.name
		permission = f.permissions
		output = output +color.white+ file_name+color.cap+ " "+file_type+" " +color.orange+ f.owner +color.cap+ " " +color.green+ f.group +color.cap+ " "+ color.cyan+ f.size +color.cap +" "+ color.white+permission+color.cap
	end for
	if not sub_files then return print(output)
	print(format_columns(output))
end function

// =======================  chmod =======================
Core["chmod"] = function(obj, recursive, perms, path_to_file)
	rec = false
	if recursive == "-r" then 
		rec = true
	else if recursive == "-d" then 
		rec = false
	end if
	if path_to_file[0] != "/" then path_to_file = Utils.pth(path_to_file)
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	file = obj.File(path_to_file)
	if file == null then return print("cannot find file "+path_to_file)
	output = file.chmod(perms, rec)
	if output.len > 1 then print(output)
end function
// =======================  chgrp =======================
Core["chgrp"] = function(obj, recursive, perms, path_to_file)
	if perms == null or path_to_file == null then return print(warning+"invalid usage")
	rec = false
	if recursive == "-r" then rec = true
	if path_to_file[0] != "/" then path_to_file = Utils.pth(path_to_file)
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	file = obj.File(path_to_file)
	if file == null then return print("cannot find file "+path_to_file)
	output = file.set_group(perms, rec)
	if output.len > 1 then print(output)
end function
// =======================  chown =======================
Core["chown"] = function(obj, recursive, perms, path_to_file)
	if perms == null or path_to_file == null then return print(warning+"invalid usage")
	rec = false
	if recursive == "-r" then rec = true
	if path_to_file[0] != "/" then path_to_file = Utils.pth(path_to_file)
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	file = obj.File(path_to_file)
	if file == null then return print("cannot find file "+path_to_file)
	output = file.set_owner(perms, rec)
	wait(0.1)
	if output then print(output)
end function

// =======================  cat =======================
Core["cat"] = function(obj, pathFile)
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	if pathFile[0] != "/" then pathFile = Utils.pth(pathFile)
	file = obj.File(pathFile)
	if file == null then return print("cat: file not found: "+pathFile)
	if file.is_binary then return print("cat: can't open " + file.path + ". Binary file")	
	if not file.has_permission("r") then return print("cat: permission denied")
	print(file.get_content)
end function
// =======================  mvdir =======================
Core["move"] = function(obj, targFilePath, pathFile, fileName)
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	targ = obj.File(targFilePath)
	if targ == null then return print("mv: no file found")
	file = targ.move(pathFile, fileName)
	if typeof(file) == "string" then return print(file)
	print(fileName+" created at path "+ pathFile)
end function
// =======================  copy =======================
Core["copy"] = function(obj, targFilePath, pathFile, fileName)
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	
	if targFilePath[0] != "/" then targFilePath = Utils.pth(targFilePath)
	if pathFile[0] != "/" then pathFile = Utils.pth(pathFile)
	
	targ = obj.File(targFilePath)
	if targ == null then return print("mv: no file found")
	file = targ.copy(pathFile, fileName)
	if file == false then return print("mv: failed to move")
	print(fileName+" created at path "+ pathFile)
end function
// =======================  rm =======================
Core["rm"] = function(obj, pathFile)
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	if pathFile[0] != "/" then pathFile = Utils.pth(pathFile)
	file = obj.File(pathFile)
	if file == null then return print("rm: cant find file")
	if file.has_permission("w") == false then return print("rm: cant write to file")
	n = file.name
	del = file.delete
	wait(0.1)
	if del.len < 1 then print("deleted "+n)
end function

/////////////////////////////////////////////////////////////
//////////////////    FILE EDIT    //////////////////////
////////////////////////////////////////////////////
inputs = {}
inputs.pos = {}

inputs.pos.setY = function(lineIndex, data)
	current_line = inputs.pos.y
	length = data.len-1
	// down
	if lineIndex < 0 and length > 0 and inputs.pos.y != 0 then  // up
		print("moving: up")
		inputs.pos.y = inputs.pos.y-1
	else if length > 0 and lineIndex > 0 and inputs.pos.y != length then // down
		print("moving: down")
		inputs.pos.y = inputs.pos.y+1
	end if
	//if globals.debug == true then print("setY: input "+lineIndex+" global: "+inputs.pos.y+"\n-----")
	inputs.pos.x = 0
	return inputs.pos.y
end function

inputs.pos.setX = function(linePos, data)
	current_position = data[inputs.pos.y-1] // gets the line we are editing
	print("SET X line: "+current_position)
	length = current_position.len-1
	if linePos < 0 and length > 0 and inputs.pos.x != 0 then // left
		print("moving: left")
		inputs.pos.x = inputs.pos.x-1
	else if length > 0 and linePos > 0 and inputs.pos.x != length then // right 
		print("moving: right")
		inputs.pos.x = inputs.pos.x+1
	end if
	//if globals.debug == true then print("setX: input "+linePos+"\nglobal: "+inputs.pos.x+"\n-----")
	return inputs.pos.x
end function

Core["edit"] = function(obj, pathFile, clean = null)
	inputs.pos.x = 0;inputs.pos.y = 0;cI = 0;bool = false;f=null;
	if clean == "-c" then bool = true
	obj = Utils.handle(obj)
	if pathFile[0] != "/" then pathFile = Utils.pth(pathFile)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	if typeof(obj) == "computer" then obj = obj.File(pathFile)
	if typeof(obj) == "file" then 
		f = obj
		if globals.debug then print("edit: file object passed "+f.path)
	else
		f = obj.File(pathFile)
	end if
	if f == null then
		return print(warning+" edit: no file found")
	else if f.has_permission("r") == false or f.has_permission("w") == false then 
		return print(warning+"edit: error with file permissions")
	end if
	
	editing = true;saving = false;raw_content = f.get_content;new_content = null
	valid_inputs = ["_","LeftArrow","RightArrow","DownArrow","UpArrow"]
	invalid_inputs = ["LeftShift","RightShift", "Tab", "LeftControl", "RightControl", "LeftAlt", "RightAlt"]
	parse = null
	while editing == true 
		display = null;lineIndex = inputs.pos.y;index = inputs.pos.x;cI = 0
		if new_content == null then 
			new_content = raw_content;parse = new_content.split(char(10))
		end if
		if globals.debug then print("Initial data: "+parse)
		count = 0
		for line in parse
			display = display + "\n"+count+".) "+line;count = count+1
		end for
		print(color.blue+color.fill+"\n"+color.white+"Editing: "+color.cap+color.yellow+pathFile+color.cap+"\n"+display)
		//if globals.debug then print("X: "+index+"\nY:"+lineIndex)
		controller = null;controller = user_input("----INPUT: "+controller+"\nX: "+index+"\nY: "+lineIndex+"\n-----\nF1 --> save\nESC --> return\n: ", bool, true)
		//controller = user_input("|", false, true)
		//if globals.debug then print("INPUT: "+controller+"\nX: "+index+"\nY: "+lineIndex)
		//if globals.debug then print(color.fill+"\nline to edit: "+l+"\nindex: "+l[inputs.pos.x])
		if valid_inputs.indexOf(controller) then
			if globals.debug then print("controller input") 
			if controller == "LeftArrow" then 
				index = inputs.pos.setX(-1, parse)
			else if controller == "RightArrow" then 
				index = inputs.pos.setX(1, parse)
			else if controller == "UpArrow" and lineIndex != 0 and lineIndex > 0 then 
				lineIndex = inputs.pos.setY(-1, parse)
			else if controller == "DownArrow" and lineIndex > -1 then 
				lineIndex = inputs.pos.setY(1, parse)
			end if
			l = parse[inputs.pos.y]
			if globals.debug then print("line to edit: "+l)
		else
			l = parse[inputs.pos.y]
			if globals.debug then print("line to edit: "+l)//+"\nindex: "+l[inputs.pos.x])
			if controller == "Escape" then 
				if globals.debug then print("c1")
				break
			// ENTER
			else if controller == "" then
				if globals.debug then print("c2") 
				parse.push("")
			// SAVE
			else if controller == "F1" then
				saving = true 
				break
			else if not invalid_inputs.indexOf(controller) then
				mut_line = ""
				if l.values.len == 0 then 
					if globals.debug then print("<color=green>this happens")
					mut_line=controller
				else 
					if globals.debug then print("<color=red>this happens")					
				end if
				for chars in l.values
					if globals.debug then print("cI?: "+cI)
					if cI == inputs.pos.x then
						if globals.debug then print("count == pos : adding "+chars+" to: "+controller) 
						if controller == "Backspace" then
							mut_line = mut_line+""
							inputs.pos.x = inputs.pos.x-1
						else if controller == "Spacebar" then
							mut_line = mut_line+" "
						else
							//inputs.pos.x = inputs.pos.x+1 // wow this was bad
							mut_line = mut_line+chars+controller//+chars//+chars+mut_line
						end if
					else
						mut_line = mut_line+chars
					end if
					cI = cI +1
				end for
				if controller != "Backspace" and controller != "" then inputs.pos.x = inputs.pos.x+1
				//if inputs.pos.x != 0 then inputs.pos.x = inputs.pos.x-1
				if globals.debug then print("mut line: "+mut_line)
				parse[inputs.pos.y] = mut_line
				if globals.debug then print("parse line: "+parse[inputs.pos.y])
				if globals.debug then print("c3") 
			end if 
		end if
	end while
	if saving then
		set = null
		newcount = 0
		for p in parse
			if globals.debug then print("p: "+p) 
			if p == char(10) or p == "\n" or p == "" then 
				set = set+char(10)
			else
				if newcount == 0 then
					set = set+p
				else
					set = set+char(10)+p
				end if
			end if
			newcount = newcount+1
		end for
		save = f.set_content(set)
		if typeof(save) != "string" then return print(f.name+" was saved!")
	end if
end function
// =======================  move =======================

// =======================  ping =======================
Core["ping"] = function(shell, ip)
	obj = Utils.handle(shell)
	result = obj.ping(ip)
	if result then
		if typeof(result) == "string" then
			print(result) 
		else
			print("Ping successful")
		end if
	else
		print("ip unreachable");
	end if
end function

// ======================= SERVICES =========================

// ======================= sniff =========================
Core["sniff"] = function()
	if globals.Mode then return print(warning+"program is operating at cfg:"+globals.Mode)
	print(init+" Listening for connections . . .")
	output = meta.sniffer
	print(output)
end function
// =======================  iwlist =======================
Core["iwlist"] = function(obj, net)
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	if devices == null or devices.indexOf(net) == null then return print(warning+"iwlist: Network device not found")
	if params[0].indexOf("eth") != null then exit("iwlist: ethernet cards not supported for this command")
	networks = obj.wifi_networks(net)
	if networks == null then return print(warning+"iwlist: invalid usage")
	info = "BSSID PWR ESSID"
	for network in networks
		info = info + "\n" + network
	end for
	print(format_columns(info))
end function
// =======================  ifconfig =======================
// Usage: ifconfig [net interface] [ip address] gateway [ip address]
Core["ifconfig"] = function(obj, addr = null, gate = null, device = null)
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	if not addr then
		router = get_router    
		if obj.is_network_active then
			lip = obj.local_ip
			pip = router.public_ip
			gw = obj.network_gateway
			if obj.active_net_card == "WIFI" then		    
				output = "\nConnected to Wi-Fi:\nEssid: " + router.essid_name + "\nBssid: " + router.bssid_name
			else
				output = "\nEthernet connection:"    
			end if
		else
			lip = "0.0.0.0"
			pip = "0.0.0.0"
			gw = "0.0.0.0"
			output = "\nNot connected to the network."
		end if
		print( output + "\n----------------\nPublic IP: " + pip + "\nLocal IP: " + lip + "\nGateway: " + gw + "\n")
	else 
		if not gate or not device then return print(error+"ifconfig invalid args")
		if not is_valid_ip(addr) then return print(warning+"ifconfig: <b>invalid ip address")
		if not is_valid_ip(gate) then return print(warning+"ifconfig: <b>invalid gateway")
		output = obj.connect_ethernet(device, addr, gate)
		if output.len > 0 then print(output)
	end if
end function
// =======================  iwlist =======================
//Usage: iwconfig [net device] [bssid] [essid name] [pass key]
Core["iwlist"] = function(obj, net)
	obj = Utils.handle(obj)
	
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	if net == "eth" then return print(warning+"iwlist: ethernet cards not supported for this command")
	//command: iwconfig
	devices = obj.network_devices
	if devices == null or devices.indexOf(net) == null then return print(warning+"iwconfig: Network device not found")
	status = computer.connect_wifi(net, bss, ess, pass)
	if typeof(status) == "string" then print(status)
end function

// =======================  iWconfig =======================
//Usage: iwconfig [net device] [bssid] [essid name] [pass key]
Core["iwconfig"] = function(obj, net, bss, ess, pass)
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	//command: iwconfig
	devices = obj.network_devices
	if devices == null or devices.indexOf(net) == null then return print("iwconfig: Network device not found")
	status = computer.connect_wifi(net, bss, ess, pass)
	if typeof(status) == "string" then print(status)
end function
// =======================  airmon =======================
Core["airmon"] = function(obj, option, device)
	if not crypto then return print("Error: Missing crypto library")
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	formatOutput = "Interface Chipset Monitor_Mode\n"
	if option != "start" and option != "stop" then return print(warning+"invalid arguments, [start|stop]")
	output = crypto.airmon(option, device)
	if not output then return print(warning+"airmon: " + device + " not found")
	if typeof(output) == "string" then return print(output)
	print(format_columns(formatOutput + obj.network_devices))
end function
// =======================  aireplay =======================
Core["aireplay"] = function(bssid, essid)
	if not bssid or not essid then return print(error+" invalid usage")
	if not crypto then return print(error+"Missing crypto library")
	result = crypto.aireplay(bssid, essid)
	if typeof(result) == "string" then return print(result)
end function
// =======================  aireplay =======================
Core["aircrack"] = function(obj, pathFile)
	//command: aircrack
	if not crypto then return print(error+"Missing crypto library")
	if pathFile[0] != "/" then pathFile = Utils.pth(pathFile)
	obj = Utils.handle(obj)
	if typeof(obj) == "shell" or typeof(obj) == "ftpshell" then obj = obj.host_computer
	file = obj.File(pathFile)
	if file == null then return print(warning+"aircrack: file not found: "+pathFile)
	if not file.is_binary then return print(warning+"aircrack: Can't process file. Not valid filecap.")		
	if not file.has_permission("r") then exit(warning+"aircrack: permission denied")

	key = crypto.aircrack(file.path)
	if key then 
		print("KEY FOUND! [" + key + "]" )
	else 
		print("aircrack: Unable to get the key" )
	end if
end function

Core["lib_catch"] = function(obj, lib, libVersion)
	ip = null
	if lib == "-r" then 
		ip = Utils.router_catch(obj, libVersion)
	else 
		ip = Utils.lib_catch(obj, lib, libVersion)
	end if
	if ip then return Core.Probe(obj, ip)
	return print(error+"with cmd: lib")
end function

// =======================  apt-get =======================
PendingUpdating = function(obj, folderPath)
	pc = obj.host_computer
	apt = include_lib("/lib/aptclient.so")
	if not apt then
		apt = include_lib(current_path + "/aptclient.so")
	end if
	pendingUpdate = []
	
	dirs = [folderPath, "/lib/cheese"]
	
	for dir in dirs
		target_folder = pc.File(dir)
		if target_folder then 
			for file in target_folder.get_files
				output = apt.check_upgrade(file.path)
				if output == true then pendingUpdate.push(file.name)
			end for
		end if
	end for
	return pendingUpdate
end function 

//  shell: Shell
// (action) p1: action: string
// (lib) p2: string | null
// (force) p3: boolean | null

// i dont even want to look at this pos 
// =======================  apt-get =======================
Core["git"] = function(shell, cmd, param=null)
	shell = Utils.handle(shell)
	aptclient = include_lib("/lib/aptclient.so")
	if not aptclient then
		aptclient = include_lib(current_path + "/aptclient.so")
	end if
	if not aptclient then return print(error+ " Missing aptclient.so library in the /lib path or the current folder")
	if cmd == "-u" then // update
		print("Updating package lists...")
		output = aptclient.update
		if output then print(output)
	else if cmd == "--" then // upgrade
		pendingPackages = PendingUpdating(shell, "/lib") + PendingUpdating(shell, "/bin")
		if pendingPackages.len == 0 then return print("c1: No updates needed")
		pkgs = ""
		c = 1
		for itemPackage in pendingPackages
			pkgs = pkgs +c+".)"+color.white + itemPackage+"\n"
			c = c+1
		end for
		print("The following packages will be updated:\n"+pkgs)
		force = null
		option = null
		if param != "-f" then 
			option = user_input("\nDo you want to continue?(y/n): ")
			if option != "y" then return print("Exiting . . .")
		end if
		counter = 0
		for itemPackage in pendingPackages
			output = aptclient.install(itemPackage)
			if output == true then
				counter = counter + 1
			else if output then
				print(output)
			end if
		end for
	print(counter + " packages updated")
	else if param then 
		if cmd == "install" then 
			print("Downloading " + param);output = aptclient.install(param)
			if output == true then print(param + " installed")
			print(output)
		else if cmd == "search" then 
			print(aptclient.search(p2));
		else if cmd == "show" then		
			print(aptclient.show(p2));
		else if cmd == "addrepo" then
			port = 1542
			output = aptclient.add_repo(param)
			if output then print(output)
			print("Repository " + param + " added succesfully.\nLaunch apt with the update option to apply the changes")
		else if cmd == "delrepo" then
			output = aptclient.del_repo(param)
			if output then print(output)
			print("Repository " + param + " removed succesfully.\nLaunch apt with the update option to apply the changes")
		else if cmd == "update" then 
			output = aptclient.install(param)
			if output == true then print("updated: "+param)
		end if
	end if
end function
//////////////////////////////////////////////////////////////////////////////  
///======================== NET SESSION =================================///
//////////////////////////////////////////////////////////////////////////
///============================ PROBE =====================///

// obj: shellobject , p1: --|ip|domain, p2: *|port
Core["Entry"] = function(obj, p1, p2 = null)
	if globals.Mode then return print(warning+"program is operating cfg: <b>"+color.white+globals.Mode)
	addr = null
	port = null
	// reg, random,
	if not p2 then
		print("p1: "+p1)
		if p1 == "-r" then 
			addr = Utils.random_ip
		else 
			addr = p1
		end if
		if globals.debug then print("net entry: c1") 
	else // random specific port
		if p1 != "-r" then return print(warning+"entry: <i>invalid usage") 
		if globals.debug then print("net entry: c2") 
		addr = Utils.player_ip(p2)
	end if
	return Core.Probe(obj, addr)
end function

Core["Probe"] = function(object, addr)
	isDomain = null
	if not is_valid_ip(addr) or not is_lan_ip(addr) then
		isDomain = nslookup(addr)
		if is_valid_ip(isDomain) then addr = isDomain
	end if
	if not isDomain and not is_valid_ip(addr) then return print(warning+" not a valid IP")

	addr_label = "HIDDEN"
	if globals.anonymous == false then addr_label = addr
	print(init+"Net Session: searching: "+addr_label)
	router = null;ports = null;isLanIp = is_lan_ip(addr);fwd_machines = [];closed_machines = [];
	if isLanIp then 
		print("lan detected")
		router = get_router;
		if not router then return print(error+" An error occured")
		ports = router.device_ports(addr) // these appear to be forwarded ports ?
	else 
		router = get_router(addr); 
		if not router then return print(error+" An error occured")
		ports = router.used_ports
	end if
		devices = router.devices_lan_ip 	// any machine on the network reachable by ping on this address 
	//optional router attack
	if not ports or ports.len == 0 then 
		input = user_input(title+color.orange+"[Alert] No forward ports found\n"+color.yellow+"[SELECT]\n1.) Exploit the router \n0.) Exit\n--> ")
		if input.val == 1 then return Core.RouterEntry(addr, devices)
		if input.val != 1 then return print(title+" exiting . . .")
	end if 

	local_machines = devices // assign this list to a refernce of machine if we have 
	print(color.blue+"><> ><>"+color.cap+color.grey+" Machines reachable by ping: "+color.cap+"[ <b>"+color.white+devices.len+color.cap+"</B> ]"+color.blue+" ><> ")
	print(color.blue+color.fill); print(color.blue+"><> ><>"+color.cap+color.grey+" Machines with fowarded ports"+color.cap+color.blue+" ><> ><>")
	choices = color.orange+"0.) Attack_Router"; num = 1;info = null;
	for port in ports
		service = router.port_info(port)
		if not service then continue
		service_parsed = service.split(" ")
		service_lib = service_parsed[0]
		service_version = service_parsed[1]
		status = color.green+"open"+color.cap
		lan = port.get_lan_ip
		number = port.port_number
		if (port.is_closed and not isLanIp) then 
			status = color.red+"closed"+color.cap
			closed_machines.push(lan)
		else  
			// insert into list of processes to exploit
			fwd_machines.push([lan, number])
			choices = choices + "\n"+color.cyan + num+".) "+color.cap+color.purple+ lan +color.cap+color.white+ " " + number +color.cap+color.green +" " + service_lib
			num = num+1	
		end if
		info = info + color.cyan+service_lib+color.cap + " " + status + " " +color.grey+service_version+color.cap + " " + color.purple+lan+color.cap+color.white+" "+number+"\n"
	end for
	if fwd_machines.len == 0 then 
		input = user_input(title+color.orange+"[Alert] No open ports found\n"+color.yellow+"[SELECT]\n1.) Exploit the router \n0.) Exit\n--> ")
		if input.val == 1 then return Core.RouterEntry(addr, devices)
		if input.val != 1 then return print(title+" exiting . . .")
	end if 
	print(color.blue+"><>"+color.cap+" "+addr_label+color.cap+"::"+color.grey+number+color.cap+" Router: <b>v"+color.white+router.kernel_version)
	if globals.anonymous == false then Utils.who(addr)
	print(color.green+"><> "+color.cap+format_columns("LIB STATE VERSION LAN PORT")+color.green+" ><>")
	print(format_columns(info))
	print(color.blue+color.fill); print(format_columns(choices)); print(color.blue+color.fill)
	response = user_input(title+color.green+"-- "+color.white+"Select Entry"+color.cap+color.grey+" * Enter to Return *"+color.cap+color.green+" --> "+color.cap+color.white)
	if response.len == 0 then return
	response = response.val
	if response == 0 then return Core.RouterEntry(addr, devices)
	lan = fwd_machines[response - 1][0]
	port = fwd_machines[response - 1][1]
	return Core.NetEntry(addr, lan, port)
end function
///============================ ROUTER ENTRY =====================///
Core.RouterEntry = function(addr, devices)
	// begin a task to begin a net session hack
	addr_label = "HIDDEN"
	if globals.anonymous == false then addr_label = addr
	hacked_object = null
	print(init+" Beginning Router Entry @ "+addr_label)
	if devices.len == 0 then return print(warning+" no devices found")
	options = "[ Computers ]"; count = 1; 
	for device in devices 
		options = options+"\n"+count+".) "+color.white+device
		count = count+1
	end for
	options = options + "\n0.)"+color.purple+" Net Router Entry\n"+color.yellow+"LAN"+color.cap+" Bounce Other Machine\n|| Return to Main\n"+color.green+"[Select] --> "+color.cap
	choice = user_input(options)
	if choice == "||" then return print("Returning . . .")
	if is_lan_ip(choice) then 
		hacked_object = auto_hack(addr, 0, choice)
	else 
		choice = choice.val
		if choice == 0 then 
			hacked_object = auto_hack(addr, 0)
		else 
			hacked_object = auto_hack(addr, 0, devices[choice-1])
		end if
	end if
	return hacked_object
end function
///============================ NET ENTRY =====================///
Core.NetEntry = function(ip, lan, port)
	ip_label = "HIDDEN"
	if globals.anonymous == false then ip_label = ip
	print(init+color.white+" Beginning Net Entry!"+color.cap+" --> "+color.grey+ip_label+color.cap+"/"+color.purple+lan+color.cap+":"+color.blue+port)
	hacked = null
	//obj = Utils.handle(object)
	if not is_valid_ip(ip) then return print(warning+ "invalid IP")
	hacked = auto_hack(ip, port)
	if globals.debug then print("we are expecting hacked_object to be map and its a : "+ typeof(hacked))
	if globals.debug then print("isa map "+(hacked isa map))
	if globals.debug then print("isa ShellObject "+(hacked isa ShellObject))
	if globals.debug then print("isa ComputerObject "+(hacked isa CompObject))
	if globals.debug then print("isa FileObject "+(hacked isa FileObject))
	if typeof(hacked) != "map" then 
	//if not hacked isa map then 
		print(warning+" "+color.white+ip_label+color.cap+" @ "+color.grey+lan+color.cap+" : "+color.orange+port+color.red+" Net Session FAILED" )
		if globals.debug then print(color.yellow+"debug: obj is of type: "+typeof(hacked)+":"+(hacked isa map))
		input = user_input("1.) Router Attack\n2.) New Net Attack \n3.) Bounce\n4.) Exit \nSELECT ->  ")
		input = input.val
		if input == 1 then
			hacked = auto_hack(ip, 0)
			if not hacked then return print(warning+ip_label+" couldnt be penetrated via router")
		end if
		if input == 2 then
			run = Core["Probe"] 
			return run(Current_Object, ip)
		end if
		if input == 3 then 
			value = user_input(color.yellow+"Enter a LAN: \n-->") 
			hacked = auto_hack(ip, 0, value)
		end if
		if input == 4 then 
			return hacked
		end if
	end if
	print("exiting net entry . . .")
	if globals.debug then print("we are expecting hacked_object to be map and its a : "+ typeof(hacked))
	return hacked
end function

// EXPLOITS
// 1. checkLib
// 1. search
// 2. create
// 3. update

Core.exp = {}
Core.exp["get_format"] = function(data)
// take file content from library file, and format it into valid params

end function

Core.exp["set_format"] = function(data)
// take raw data from gethacks, and format it into parsable txt

end function

Core.exp["search"] = function(library)
	exploits = null
	base = globals.Shells[0][0]
	user = base.user
	base = Utils.handle(base)
	//if typeof(base) == "shell" or typeof(base) == "ftpshell" then base = base.host_computer
	// check base shell dir
	fsPath = ["/home/"+user+"/src", "/home/"+user+"/src/dict", "/home/"+user+"/src/dict/exploits"]
	for file in fsPath
		f = base.host_computer.File(file)
		if f == null then
			return print("Missing "+file)
		else if f.name == "exploits" then 
			break
		end if
	end for
	depot = base.host_computer.File("/home/"+user+"/src/dict/exploits")
	if not depot then return print(error+" no exploit folder found") 
	for file in home.get_files
		if globals.debug then print("file: "+file.name)
		if file == null or file.is_binary then 
			print("Missing "+file)
		else if file.name == library then
			exploits = file.get_content 
			break
		end if
	end for
	// return info
	return explpoits
end function


Core.exp["create"] = function(object, library, data)
	exploits = null
	valid_path = null
	// check base shell dir
	fsPath = ["/home/"+user+"/src", "/home/"+user+"/src/dict", "/home/"+user+"/src/dict/exploits"]
	for file in fsPath
		f = base.host_computer.File(file)
		if f == null then
			return print("Missing "+file)
		else if f.name == "exploits" then
			valid_path = true 
			break
		end if
	end for
	//depot = base.host_computer.File("/home/"+user+"/src/dict/exploits")
	if not valid_path then return print(error+" no exploit folder found") 
	exploit_file = base.host_computer.File("/home/"+user+"/src/dict/exploits/"+library)
	formatted = @Core.exp["set_format"]
	content = formatted(data)
	
	
	if exploit_file == null then
		if globals.debug then print("exp: create c1")  
		create = base.host_computer.touch("/home/"+user+"/src/dict/exploits", library)
		verify = base.host_computer.File("/home/"+user+"/src/dict/exploits/"+library)
		if verify then
			edit = exploit_file.set_content(content)
			if typeof(edit) == "string" then return print(warning+"failed to set file content")
			if edit == 1 then print(color.green+" Exploit Save --> <b>OK</b>"+color.cap+" Library: "+color.white+library) 
		end if
	else 
		if globals.debug then print("exp: create c2") 
		content = exploit_file.get_content
		if content.len > 1 then
		if globals.debug then print("exp: create c2a")  
		edit = exploit_file.set_content(data)
		if typeof(edit) == "string" then return print(warning+"failed to set file content")
		if edit == 1 then print(color.green+" Exploit Save --> <b>OK</b>"+color.cap+" Library: "+color.white+library) 
	end if
	return true
end function
